<Javascript>
すべてのファイル内容を読み込んでから実行する(javascriptファイルにおいては)（HTMLなどとの連携は関係なく）
=>後に関数の記述をしてもOK、ローカル変数とグローバル変数の上書き関係も定義前後関係がない

Javascriptはデータ型の指定なし

Javascriptのバリデーションはブラウザに依存するため、サーバサイドでバリデーション必要

複数のscriptタグを1つのHTMLに持つことが出来る




<モーダルウィンドウ>
ポップアップなどのウィンドウ

<メソッドとプロパティ>
Javaでいうメソッドとフィールド

<document>
現在のページを示す変数

<write()>
文字列のHTML出力

<console.log()>
コンソールのログ出力
その他).debug (出力レベルが高い) .info, .warn, .error


<window>
ブラウザを示す変数
document: HTMLプロパティを持つ
window: documentを含め、アラートやURLなど、ブラウザにおけるプロパティを持っている


<scriptの属性>
・src
・async = 非同期のスクリプト読み込み
		 実行はHTMLパーズの完了後とは限らない
		 Google Analyticsなど、DOMに関係ないものに使う
		 <script async></script>
・defer = 非同期読み込み
		 実行はHTML解析の後
・charset

<レンダリング>
jsはコードを上から順にHTML解析を行う
UI上scriptはbodyの最後に書くことが望ましい
（jsを先にダウンロードしても実行は最後のため、遷移体感時間に影響しない）

<HTMLパース>
HTML解析のこと

<var>
変数宣言メソッド
複数同時宣言可能　var a,b,c
スコープは変数の中　(｛｝ブロックではない)
通常、関数内からグローバル変数の参照可能。しかし、グローバル変数と同名のローカル変数を関数内に宣言する場合、関数内においては、そのローカル変数が宣言前であっても、その変数名に入っている値はundefined(つまり、はローカル変数として扱われる)

例)
var x = 0;

function func(){
console.log(x);
var x = 1
};

func();　//undefined
-----------------------------
var x = 0;

function func(){
console.log(x);
};

func(); // 0


<let>
機能はvarと同様
スコープがブロック単位

<const>
定数宣言

<文字列型>
\ は以降に改行以外これない
＝\を使うと複数行に単文の文字列入力が出来る

<エスケープシーケンス>
\を付けることで文字列内で特殊入力が可能
\\ => \, \" \" => "", \n => 改行, \t => タブ

<Number()>
INT型変換

<parceFloat()>
FLOAT型変換

<指数表記>
○○の10乗という表記法
例)　3e+2 => 300 // 3を+2桁分ずらす
　　 1e-3 => 0.01 // 1を-3桁分ずらす
※プラスは省略可能

<boolean>
false(0, null, undifined, 空文字)

<null>
0, falseとして動く

<オブジェクト型>
Rubyのハッシュ的な感じ
参照渡し

-プロパティの呼び出し
	=>　ドット記法と連想配列記法
	ドット配列　obj.name
	連想配列　obj["name"]

	※プロパティ名にハイフンや空白は使えず、使う場合はプロパティ名をクォーテーションで囲む(この場合、呼び出しは連想配列記法しか無理)

-プロパティの追加
	ドット記法で普通に追加
	obj.number = 1234; //numberプロパティの追加

-プロパティの削除
	=> deleteメソッド
	delete obj.number

-メソッド
	オブジェクト内の関数のこと
	プロパティの値として登録される

-オブジェクトの作成方法

	（オブジェクトリテラル）
	ブレス{}で囲んで作成
	そして、{}内にプロパティとメソッドを記述できる
	var obj = {
		name : "OO", //カンマで区切る
		age : 10,
		method : function(){}
	};
	※インスタンスを一つずつ作るイメージ

	（関数とnew演算子）
	javascriptではコンストラクタの専用構文はなく、new演算子に呼ばれる関数をコンストラクタと呼ぶ。
	またコンストラクタ作成にはthisキーワードが必須であり、thisを付けない場合、そのプロパティはそのコンストラクタに属さない。(普通の関数内変数として隠蔽される　=　インスタンスに反映しない)
	(コンストラクタは関数と区別するため、名前の始めを大文字にする)
	function Person(name){
		this.name = name;
		this.greet = function(){
			console.log("Hello, My name is" + this.name);
		}
	}

	var obj = new Person("NAME");
	※クラスとは別っぽい?

	<thisキーワード>
	オブジェクト内包されていれば、そのオブジェクト
	内包されていなければ、windowオブジェクト(windowもオブジェクトのため)
	addEventListener()内では、そのターゲット要素のこと

-オブジェクトの種類
	-ビルトインオブジェクト(組み込みオブジェクト)

		・標準ビルトインオブジェクト
			Javascript標準仕様のオブジェクト
			undefinedプロパティやparceFloat()メソッド、Mathコンストラクタなどが属する。

		・ブラウザオブジェクト
			HTML要素を操作するためのオブジェクト

		・DOMオブジェクト
			ブラウザが提供するオブジェクト
			このオブジェクトを通じて、現在のページのURLや履歴にアクセスすることができる

<標準ビルトインオブジェクト>
-Object 全てのオブジェクトの元となる基本オブジェクト
-Function 関数を作成するためのオブジェクト
-Boolean 論理値を扱うためのオブジェクト
-String 文字列操作をするためのオブジェクト
-RegExp 正規表現を表わすオブジェクト
-Array 配列を扱うためのオブジェクト
-Number 数値を扱うためのオブジェクト
-Math 数学計算を行うオブジェクト
-Date 日付や時刻を扱うためのオブジェクト

これらのオブジェクトの使い方
１．コンストラクタとして、new演算子でインスタンスを作り、プロパティにアクセスする

２．オブジェクトリテラルやキーワードを使う(実行速度が速い)

配列の作成　x = new Array(); <=> x = [];
論理値の作成　x = new Boolean(); <=> x = false; ( デフォルトのプリミティブ値はfalse)
関数の作成　x = new Function(); <=> x = function(){};
数値の作成　x = new Number(); <=> x = 0; (デフォルトのプリミティブ値は0)
オブジェクトの作成　x = new Object(); <=> x = {};
正規表現の作成　x = new RedExp(); <=> x = /(?:)/;
文字列の作成　x = new String(); <=> x = "";

Javascriptでは、プリミティブ値も必要時にオブジェクト変換されて、プロパティやメソッドにアクセスできる(自動型変換機能)


<プリミティブ値>
値一つだけを持つ基本の型

<配列>
var array = [1,2,3];
	array[1];

<typeof()>
データ型を返す(初期値undefined)

<型の自動変換>
プリミティブ型に"."を付けると一時的にオブジェクトになる
	=>str.length => Stringオブジェクトのlengthプロパティのアクセス

<slice()>
第1引数で指定した要素から第2引数で指定した要素までを返す。元の配列に影響なし。

<join()>
配列の各要素を指定の文字列で連結し、結果を文字列で出力

<Array()>
引数の数のインデックスを持った配列を作成(undefined)

<＋>
文字列の数字につけると文字列を数値に変換
例)　5 + +"3.25" => 8.25
　   +null, +false => 0
　   +true => 1
     変換不可　=>　NaN

<===>
厳密等値（数値が一致かつ、データ型が一致）
1 == "1" => true, 1 === "1" => false
※==，!=は型変換を行ってから比較

<!==>
厳密不等値（数値が一致しないかつ、データ型が一致しない）
1 != "2" => true, 1 !== "2" => false

<toString()>
引数の進数に変換

<ビット演算子>
2進数の集合演算
ｰ論理積　&
 - 1000 & 1001 => 1000
-論理和　|
 - 1000 | 1001 => 1001
-排他的論理和　^
 - 1000 ^ 1001 => 1
-否定　~
 - ~1000 => 0111 ※32bitと64bitがある
ｰシフト　<< >>
2進数を右オペランド分桁をずらす（1桁で2のnで変化する）
 - 1000<<1 => 2000
 - 1000>>1 => 500

<ゼロ埋め右シフト>
-1000>>>1
2進数の桁をまるごと右へスライドして、上位ビットを0で埋める

<**>
累乗

<三項演算子>
X = a>b ? a:0;
?の前の条件式が、trueなら:の前のオペランド、falseなら:の後のオペランドが返される

<switch>
switch(x){
	case 0 :
	case 1 :
		break;
	default:
}

<ゼロパディング>
0を付けて数値の桁数を合わせる

<スクリプト言語とインタプリタ言語>
スクリプト言語 = 明確な定義はない（比較的簡単に書ける言語の総称)
インタプリタ言語 = コンパイル不要の言語
※スクリプト言語のほとんどはインタプリタ言語


<ロールオーバー>
マウスを要素に重ねた時(マウスオーバー)cssを変化させる現象

<スニペット>
よく使うコードを登録して呼び出す機能

<フォーク>
分岐を意味する(元ソースから分離して別バージョンを作る)

<デバック>
プログラム内のおかしな場所、またその改修のこと
console.debugはログ出力レベル(verbose)で出力される
normalでは出力されない


<デベロッパーツール>

	<コンソールパネル>
	プログラム実行可能。
	[Enter] = 実行, [shift] + [Enter] = 改行

	<イベントリスナーパネル>
	イベントが発生するとどのような処理が行われるのかが確認できる
	[Ancestors All]　=>　該当する要素と親要素のイベントリスナーを確認できる
	[Framework Listener]　=>　jQueryなどのライブラリやフレームワークが提供する機能を使ってイベントリスナーを登録した場合、そのコードを素通りして、機能を提供したライブラリやフレームワークのコードのほうが表示される。しかし、このオプションをチェックすると、イベントを定義したコードを確認できる。

<ブレイス>
{}のこと

<ブラケット>
[]のこと

<コメントアウト>
//
/**/

<ランディングページ>
LP。　1つの商品やサービスを売るための一枚の長いWEBページ

<非同期処理>
HTMLパース中に、JSのダウンロードを行うことで遷移を早くする技術
ｰ処理内によそからデータが必要なものがある場合、そのリクエスト結果が帰ってくるまでの間他の処理を先に行い、必要なデータがそろった時点で実行すること。
コールバック関数との組み合わせが強力

<コールバック関数>
関数の引数として渡される関数のこと
関数の引数に渡す関数（=コールバック関数）は無名関数か、関数名の（）無しで渡す。
関数に()を付けると実行してしまうため、コールバック関数には()を付けない
--------------------------------------
function exec(callbackFunc, MSG){//コールバック関数に引数を渡したい場合は親関数の第二引数として渡して、処理内で実行する
	callbackFunc(MSG);
};
var myCallBack = function(MSG){
	console.log(MSG);
};

exec(myCallBack, "hello");


<HTML内に<script>>
HTTP通信を減らせる

<リテラル>
変数と定数以外のデータ

<UML>
設計図表記の規格の1つ

<for>
処理の順番(初期化式->条件式->ブロック内の処理->増加文の評価)
for (var i = 1, j = 3; i<=3; i++, j--){
	処理
}

<dlタグ>
「DL」とは「definition list（定義）」の略で、定義リストを表すタグです。
定義リストは<dl>タグで範囲で表し、定義する用語（Definition Term）を<dt>タグで、用語の説明（Definition Description）を<dd>タグで表します。
この定義語と用語の説明のセットは、複数表記することが可能です。
<dl>
<dt>用語</dt>
<dd>用語に対する説明</dd>
</dl>


<!hoge による判定>
if (!hoge) { ... }
この条件が true になるのは上の表から分かるように
null, undefined, 0, 空文字(''), false になります.
※注意点
数値を受け取るかどうかに気をつけてください.
何故なら 0 の場合も true になっちゃうので 0 を渡した時に
意図しない挙動をする可能性があるからです.

<value>
そのHTML要素が持つ入力内容

<do while>
do{
	処理
} while(条件);
全てのループにおいて処理が先
※条件式の範囲に注意


<カスタムプロパティ>
CSSにおいて、よく使うcolorなどを代表的な一つの変数に代入しておく記法によって、作られるプロパティ
:root{
	--main-bg-color: brown;
}

<with>
with( Math){
	console.log("最小:" + min(a,b));
};
Mathオブジェクトのmin()メソッドをオブジェクト名なしで呼び出す

<リスト>
数値や文字列など複数の値を並べた構造のこと
リストを変数に代入したものを配列という
書き方：ブラケット[]とコンマで書く

配列の値は要素と言われる

<配列>
作成方法：
１.リストの代入　[1,2,3]
２.Array()オブジェクトの利用
	引数1つの場合は、インデックスの数
	2つ以上の場合は、その数字を要素に取る配列
	ｰvar list = Array(1,2,3)// list[1] => 2
	-var list = Array(1)// list[0] => undefined
ー var list = new Array(1,2,3);

３.[]リテラルを使って作るのが基本
	var list = []//初期化　要素数も要素もリセット
	var list = [2]　リテラルを使うと一つの要素でも配列を作れる

ー要素に変数・式を用いることもできる
var y = 1;
var list = [y, y*2]

-メソッドの追加
var list = [];
Object.prototype.meth = funtion(){}

<forの種類>

<for in>
for ( 変数　in オブジェクト){
	処理
}

オブジェクトの各要素にアクセスして、プロパティ名を一個ずつ取り出す
(プロパティの順序を保証しない)
(メソッドにもアクセスする)

※配列での使用も可能
配列の場合は基本インデックス
しかし、カスタムプロパティやカスタムメソッドもループ処理対象になるため、for文の方が無難
※ここでのカスタムプロパティやカスタムメソッドはプロトタイプチェーン上のプロパティやメソッドのこと。

ｰfor of
変数に要素そのものを代入する

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
<Object>
全てのオブジェクトのもとになる基本のオブジェクト

※new演算子はメモリ上に記憶場所を確保して、オブジェクトを作成し、ポインタを返す。
　そのポインタが格納された変数がインスタンス、
　メモリ上で作成されたオブジェクトをインスタンスオブジェクトという。
また、Number/string/Booleanはインスタンス==オブジェクト


----------------------------------------
オブジェクト[プロパティ名]　ブラケットでプロパティにアクセス

※Javascriptの場合、それでプロパティの生成もできる
--------------------------------------

-コンストラクタプロパティとインスタンスプロパティ
	・コンストラクタプロパティ　=　コンストラクタに属するプロパティで、インスタンスからは呼び出せないもの。
	※プリミティブ値が一時的に変換されるのは、オブジェクトそのものなので、こっちのメソッドが使える。

		<Object.keys()>
		指定したオブジェクトのすべてのプロパティ名を配列で返す
		プロトタイプチェーンをさかのぼらない

		<Object.setPrototypeOf()>
		プロトタイプを設定する
		(言語開発をするようなものなので、避けるべき)

		<Object.values()>
		指定したオブジェクトの値を配列として返す。

		<Object.getOwnPropertyNames()>
		列挙不可のプロパティを含めて、調べることができる。

	・インスタンスプロパティ　=　インスタンスの作成が必要なプロパティ

		<constructorプロパティ>
		インスタンスのプロトタイプを作ったObject関数の参照を返す

		<hasOwnProperty()>
		オブジェクトに指定したプロパティが継承されたものではなく、自身に直接属するプロパティかどうかを論理値で返す。(プロトタイプチェーン上ではない)
		---------------------------------------
		const object1 = new Object();
		object1.property1 = 42;

		console.log(object1.hasOwnProperty('property1'));
		// expected output: true

		console.log(object1.hasOwnProperty('toString'));
		// expected output: false

		console.log(object1.hasOwnProperty('hasOwnProperty'));
		// expected output: false
		----------------------------------------------

		<isPrototypeOf()>
		オブジェクトが指定したオブジェクトのプロトタイプチェーンに含まれるかを論理値で返す
		※自分が他のオブジェクトのプロトタイプチェーンに存在するか(=自分が親かどうか)

		<propertyIsEnumerable()>
		指定したプロパティが列挙可能かを論理値で返す。

		[Enumerable]の値とは、列挙をする時に意図的に列挙できないように設定するもの。
		組み込みオブジェクトのプロパティは意図的にfor文とかで列挙しないようにしてある。

		<toLocaleString()>
		toString()を呼び出す

		<toString()>
		オブジェクトから文字列情報を返す

		<valueOf()>
		指定したオブジェクトの値を返す


	<Object.prototype>
	Objectはベースとなる特殊なオブジェクトで、すべてのオブジェクトはObject.prototypeのプロパティとメソッドを継承する。
	-String.prototype.speak = function(){};とすることで、Stringオブジェクトのコンストラクタをカスタムできる。
	=> 全てのインスタンス間でメソッドを共有できる(メモリの圧迫を押さえる)

	※ちなみにFunctionもオブジェクトなので、基本的になんでもオブジェクト。
	※prototypeプロパティとは、そのコンストラクタとその子要素が共有して持っている、データの格納庫。みんなで同じものを共有している。

	<記述>
	Object.prototype = {
		getName: function{
			return this.name;
		},

		getAge: function(){
			return this.age;
		}
	}
	※プロトタイププロパティに、オブジェクト形式で入っている

	<プロトタイプチェーン>
	参照されたプロパティがオブジェクトにない場合、プロトタイプのオブジェクトをたどり、該当するプロパティがあればそのプロパティが参照される仕組みのこと。直上のオブジェクトのプロトタイプだけでなく、その上にまだプロトタイプがあればnullになるまでさかのぼる。
	※逆の参照は行われない。

	-プロトタイプの継承方法
	子オブジェクトのprototypeに親オブジェクトのインスタンスを代入する
-------------------------------------------------------
	function User(){};
	User.prototype.a = "relax";

	function Member(){};
	Member.prototype = new User(); // 継承
	Member.prototype.b = "nervious";　//継承より先にMember固有のprototypeを記述すると継承によって上書きされる

	var user = new User();
	var member = new Member();

	console.log(user.a);　//relax
	console.log(member.a); //relax //プロトタイプチェーンによる参照
	console.log(member.b); //nervious
	console.log(user.b); //undefined　//親オブジェクトから子オブジェクトのprototypeの参照は不可
---------------------------------------------------------


<Stringオブジェクト>
インスタンスプロパティは、lengthのみ
インスタンスメソッドは、
concat()　:　文字列を結合し、結果文字列を返す。
substr()　:　第一引数に指定したインデックスから、第二引数分の長さの文字列を返す
substring()　:　開始インデックスと終了インデックスを指定して、そこのある文字列を返す。
※他のオブジェクトとほぼ一緒
indexOf(), lastIndexOf(), slice(), split(), match(), replace(), search()


<Array>
コンストラクタプロパティは　length
コンストラクタメソッドは　isArray() : オブジェクトが配列かどうか判別する

インスタンスメソッド
ｰ破壊的メソッド
	ｰスタックメソッド
	配列の末尾を扱うメソッド
		<push()>
		配列の末尾に要素を追加し、追加後の配列の長さを返す

		<pop()>
		配列の末尾の要素を削除し、削除された要素を返す

	ｰキューメソッド
	配列の先頭を扱うメソッド
		<unshift()>
		配列の先頭に要素を追加し、追加後の配列の長さを返す。

		<shift()>
		配列の先頭の要素を削除し、削除された要素を返す。

ｰその他メソッド
<concat()>
引数に指定した配列を結合し、新しい配列を返す
元の二つの配列に影響は与えない

<indexOf()>
引数に指定した値とマッチする要素を探し、最初にマッチした要素のインデックスを返す。
マッチしない場合はｰ1を返す
　ー<lastIndexOf()>
	ほぼindexOf()と同じだが、複数の要素にマッチした場合は最後にマッチした要素のインデックスを返す。

<splice()>
配列の任意の場所に要素を削除、追加できる。
splice()で削除した場合、削除した要素の配列が返される。
引数：インデックス、削除する数(0の場合削除しない)、追加したい要素...

<sort()>
整列

<reverse()>
逆順

<map()>
配列の全ての要素に対し、引数に指定した関数の処理を施し、その結果の配列を返す。元の配列に影響はない


ｰArray.forEach(function(val){
	console.log(val);
});
配列に対してEach処理を行う
引数のFuncに変数valを設定し、valに各要素を代入する。nullはスキップされる。

引数は3つ受け取れる
1つ目：要素
2つ目：インデックス
3つ目：配列（自身）

これらを処理の中で使える。


<toString()>
配列とその要素を表わす文字列を返す
--------------------------------------
const array1 = [1, 2, 'a', '1a'];

console.log(array1.toString());　// "1,2,a,1a"
---------------------------------------



<配列のコピー>
配列は他の変数に代入しても、参照渡しのためコピーできない
=>slice()を使ってコピーできる


<Date>
引数なし　=>　現在時刻
"11/1/2012" => Thu Nov 01 2012 00:00:00
(2018, 2, 22, 12,16, 00) => Thu Mar 22 2018 12:16:00 // 月は0月から始まる

コンストラクタメソッド
Date.now() => UTCからの経過時間をミリ秒単位で返す
Date.UTC() => UTCから引数までの経過時間をミリ秒単位で返す。

インスタンスメソッド
	-get系
	getDate() => 日付(1～31)
	getDay() => 曜日(1～6)
	getFullYear() => 西暦(4桁)
	getHours() => 時(0～23)
	getMilliseconds() => ミリ秒(0～999)
	getMinutes() => 分(0～59)
	getMonth() => 月(0～11)
	getSeconds() => 秒(0～59)
	getTime() => UTCからの経過時間をミリ秒単位

	-set系
	setDate(日) => 日を設定する
	setFullYear() => 西暦を設定
	setHours() => 時間を設定する
	setMilliseconds() => ミリ秒
	setMinutes() => 分
	setMonth() => 月
	setSeconds() => 秒
	setTime() => UTC経過時間

	-to系
	toDateString() => Dateオブジェクトの日付を英語表記で返す
	toTimeString() => Dateオブジェクトの時刻を文字列で返す。
	toUTCString() => UTCの文字列で返す
	valueOF() => UTCからの経過時間をミリ秒単位の時刻で返す
	その他
	-toISOString()
	-toJSON()
	-toLocaleDateString()

<Mathオブジェクト>
インスタンスが不要

-コンストラクタプロパティ
	・PI　円周率
	・SQRT2　2の平方根

-コンストラクタメソッド
	・abs()　引数の絶対値
	・ceil()　引数の小数点以下切り上げ
	・floor()　引数の小数点以下切り下げ
	・log()　引数の自然対数
	・max()　引数内の最大値を返す
	・min()　引数内の最小値を返す
	・pow(x,y)　xをyで累乗した値
	・random()　0以上1未満の乱数
	・round()　引数を四捨五入
	・sqrt()　引数の平方根


<ランダム値>
Mathオブジェクトのrandom()を使う。ランダム値に必要数＋1をかけて使う。

<組み込み関数>
isNaN(値) 引数の値がNaNか判定
parceFloat()　文字列　=>　浮動小数点
parceInt()　文字列　=>　整数

<NaN>
Not a Numberのことで、Numberオブジェクトに属すが、数値以外を表わすもの。
0の除算や、NaNを用いた演算を行うと結果として出力される

<URL>
ページの番地と情報を渡すクエリパラメータで構成される。
https://rfs.jp/?パラメータ名=パラメータの値&パラメータ名=パラメータの値・・・
※&(アンパサンド)で区切ることで、複数のパラメータを指定できる

-エンコード
	https://rfs.jp/?s=関数　=>  https://rfs.jp/?s=%E9%96%A2%E6%95%B0

encodeURI()　:URL全体をエンコードするには便利。メタ文字や記号はエンコードしない。

encodeURIComponent()　:文字列としての記号をエンコードする場合にはこっちを使う。全てエンコードする。
例)パラメータ値に&が使われる時、url = "https://rfs.jp/?s=" + encodeURIComponent("A&B");

-デコード
	decodeURI()　:encodeURI()に対応
	decodeURIComponent()　:encodeURIComponent()に対応
※デコード出来ない文字列がある場合、エラーでスクリプト終了する。
なので、これらのメソッドを使う場合は例外処理のtry catch文で処理する。


<エスケープ>と<エンコード>

-エスケープ
HTMLでは「< 」を「＆ｇｔ；」へ変換することをエスケープ処理と呼称します。
この場合、画面上はエスケープしても「<」と表示されるので内部処理上は見た目が変わりますが、
画面表示する際はエスケープ後文字列そのものは表示されません。

-エンコード
情報を暗号や通信に適した形式（コード）に変換すること。動画などの場合、この「形式」のことをコーデックと呼びます。
例えばURLコードへエンコードすると「半角スペース」は「%20」へ置換されます。そしてURLを見てみるとエンコード後の文字列がそのまま表示されています。


<ブラウザオブジェクト>
ドキュメントを含む、様々なブラウザの機能にアクセスするためのオブジェクト郡

階層構造を成しており、最上位のwindowオブジェクトから下層のオブジェクトにアクセスできる
【ドット記法】
window.location.href（通常はwindow省略）

<windowオブジェクト>
ダイアログボックス、スクロールなどのウィンドウ操作、印刷などを行うメソッド、画面サイズ、スクロール位置を取得するプロパティを持つ

プロパティ（インスタンスプロパティ？　どちらかというと）
	-frameElement　:　自身を開いている元のフレーム要素を返す(ウィンドウが別の文書に埋め込まれている場合)
	-frames　:　すべてのフレームにアクセスするための配列を返す
	-innerHeight　:　スクロールバーを含むブラウザウィンドウの内側の高さを返す
	-innerWidth　:　スクロールバーを含むブラウザウィンドウの内側の横幅を返す //コンテンツとスクロールバーの範囲（タブとかは含まない)
	-outerHeight　:　ブラウザウィンドウ全体の高さを返す
	-outerWidth　:　ブラウザウィンドウ全体の横幅を返す　//タブとかメニューを含め、ブラウザのウィンドウ全体
	-pageXOffset　:　ページの左端から水平方向にスクロールした位置をピクセルで返す
	-pageYOffset　:　ページの上端からスクロールした位置をピクセルで返す　//端からどれだけ離れたところにスクロールしているか
	-screenX　:　ウィンドウの水平方向の位置を返す
	-screenY　:　ウィンドウの垂直方向の位置を返す　//画面とウィンドウの位置関係

メソッド
	-alert()　:　OKボタンのみのアラートダイアログを表示する
	-confirm()　:　確認ダイアログを表示する。OK、キャンセルのどちらを押したかを返す
	-prompt()　:　入力ダイアログを開く。OKを押した場合は入力した値、キャンセルの場合はnullを返す
	-print()　:　印刷ダイアログを開く
	-scroll()　:　絶対位置を指定してスクロールする
	-scrollBy()　:　相対位置を指定してスクロールする
	-setTimeout()　:　指定した時間が経過した後、コールバック関数を実行、もしくは式の評価を行うtimeoutIDを返す
	-clearTimeout()　:　setTimeout()が返すtimeoutIDを使って、登録されたタイマー処理を削除する
	-setInterval():　指定した間隔でコールバック関数、もしくは式を繰り返し呼び出します。intervalIDを返す
	-clearInterval()　:　setIntervalが返すintervalIDを使って、登録されたタイマー処理を削除する

<タイマー処理>
setInterval()を使って、繰り返しコールバック関数を実行することで、連続的に動的変化を起こす
----------------------------------------------------------------------------------
window.setInterval( function() {     // ID名timerの要素の内容に、現在時刻を出力
	document.getElementById( "timer" ).innerHTML = new Date().toLocaleString();
}, 1000 );

-----------------------------------------------------------------------------------
第一引数:コールバック関数
第二引数:実行間隔（ミリ秒）
第三引数以降：自由

返値:intervalID
=>clearInterval()に渡して実行すると、処理を削除する

<setTimeout()>
setInterval()と同じような動作。ただし、処理は1回のみ。


<Formオブジェクト>

	HTML　フォーム要素
		-テキストボックス
			<input type="text"> //1行文のテキスト入力
		-ラジオボタン
			<input type="radio">　//どれか一つのボタン選択を受け付ける
		-チェックボックス
			<input type="checkbox">　//複数のボタン選択を受け付ける
		-パスワード入力ボックス
			<input type="password">　//パスワード入力を受け付ける
		-セレクトボックス
			<select>　//一つ、もしくは複数のメニュー選択を受け付ける
		-テキストエリア
			<textarea>　//複数行のテキスト入力を受け付ける
		-ボタン
			<button type="button">　//ボタンに関連づけられたアクションはなく、Javasriptで処理することが前提のボタン
		-リセットボタン
			<button type="reset">　//フォームに入力された内容などをリセットする
		-サブミットボタン
			<button type="submit">　//フォームをサーバに送信する

		-オプション
			<option>　//セレクトボックスの項目を設定する
		-ファイル選択
			<input type="file">　//ファイルを選択するモーダルダイアログを表示し、選択したファイルのパスを受け取る
		-非表示データ
			<input type="hidden"> //表示されないが、サーバには送信される

		-メールアドレス
			<input type="mail">
		-検索テキスト
			<input type="search">
		-電話番号
			<input type="tel">
		-URL
			<input type="url">

		-数値
			<input type="number">
		-レンジ
			<input type="range">
		-色
			<input type="color">

		-日付
			<input type="date">
		-UTCによる日時
			<input type="datetime">
		-ローカル日時
			<input type="datetime-local">
		-月
			<input type="month">
		-週
			<input type="week">
		-時間
			<input type="time">

			<参考>　https://codepen.io/tomatosoup1206/pen/PoPOQbR


	フォームへのアクセス
		-getElementById()、getElementByClassName()でもアクセス可能

			しかし、フォーム要素にID名かクラス名が必要

		-Formオブジェクトを使ってアクセス

			-連想配列でアクセス
				document.forms[インデックス/name属性].elements[インデックス/name属性]
				document.forms[インデックス/name属性][インデックス/name属性]

			※document.formsは、フォームの配列を返すので、フォームのインデックスを指定するか、name属性をしていする。
			※インデックスはコード内の順番通りに割り振られる。（HTMLの順番をいじると、変更が難しいため通常は使わない）
			※あるフォームの全ての要素に対して処理する場合は、インデックスを使ってfor文を回すのが便利

			-ドット記法でアクセス
				document.フォームのname属性.フォーム要素のname属性


	フォーム要素の操作
		プロパティはJavascript内で、取り出したformオブジェクトにドット記法で付けるだけ
			有効にしたい場合は、アクセス後に　= true　とする。

		-値をいじる
			valueプロパティ

		-フォームの入力不可
			disabledプロパティ

		-ラジオボタン/セレクトボックスの選択
			checkedプロパティ/selectedプロパティ

		-選択肢の個数（セレクトボックス、ラジオボタン、チェックボックスなど）
			lengthプロパティ

		-選択肢の初期値
			defaultCheckedプロパティ

		-選ばれている選択肢のインデックスの取得
			selectedIndexプロパティ

		-テキスト内容
			textプロパティ

		-テキストの選択
			select()メソッド

		-テキストエリアの行数変更
			rows()プロパティ

		-イベントのデフォルト動作を停止
			preventDefault()
			=>イベントが行われた時、defaultで決まっている動作があるが、その動作を停止させるメソッド。
			-------------------------------------------------------------------------------------------
				document.forms[].addEventListener("submit", function(a){
					a.preventDefault();       //aはEventオブジェクトであり、この場合submitを参照
				});
			-----------------------------------------------------------------------------------------
				//つまり、submitされた時、preventDefault()（初期動作をしない）ことを実行するから、submitを判定。aは特に関係ない？


<Locationオブジェクト>
URL情報の取得、ページ移動、リロードなどを行う。

	-プロパティ
		-hash　:　ドキュメントの#以降のアンカーを取得、もしくは指定したアンカーに移動
		-host　:　ドキュメントのポート番号を含めたホスト情報を取得、設定
		-hostname　:　ドキュメントのホスト名を取得、設定
		-href　:　ドキュメントのURLを取得、もしくは指定したパスへ移動
		-pathname　:　ドキュメントのパスを取得、もしくは指定したパスへ移動
		-port　:　ドキュメントのポート番号の取得、設定
		-protcol　:　ドキュメントのプロトコルの取得、設定
		-search　:　ドキュメントのクエリを取得、設定

	-メソッド
		-assign()　:　指定したURLへ移動。新しいURLは閲覧履歴に追加され、ヒストリーバックで元のページに戻れる。
		-reload()　:　現在のページを再度読み込み
		-replace()　:　指定したURLへ移動。新しいURLと置換するので、ヒストリーバックで元のページに戻れない。


<アンカー>
ページ内で、さらに細かく遷移先を指定したもの
※URLの#以降の部分

<クエリ>
-データベースに出す命令(検索)のこと
-検索エンジンに出す検索ワードのこと
※URLの?以降の部分　パラメーターのところ


<Historyオブジェクト>
	履歴にアクセスできるオブジェクト
	-メソッド
		histroy.back()　:　一つ前のページに戻る
		history.forward()　:　一つ先のページに進む


<Navigaterオブジェクト>
	ユーザーエージェントからブラウザの種類やバージョン情報などを取得できる。

	-navigater.appCodeName　:　ブラウザのコード名(プログラムの名前的な)
	-navigater.appName　:　ブラウザの名前
	-navigater.appVersion　:　ブラウザのバージョン
	-navigater.userAgent　:　ブラウザのユーザーエージェント

	※これを用いて、メディアクエリなんかもできる


<screenオブジェクト>
	ディスプレイのサイズや、色数などの情報を取得できる。

		-screen.width　:　ディスプレイ幅
		-screen.height　:　ディスプレイ高さ
		-screen.availWidth　:　タスクバーなどを除くディスプレイ幅
		-screen.availHeight　:　タスクバーなどを除くディスプレイ高さ




<DOM>(ドキュメントオブジェクトモデル)
HTMLをオブジェクトとして扱うための規格で、HTMLをツリー上の集合として管理する。
ユーザーの操作イベントを受け取る仕組みが用意されている。

	<getElementById()>
	HTML要素を取得（ID値指定）返り値は取得要素のオブジェクト
	同じIDが複数ある場合は、最初にヒットしたもの
	ない場合はnullを返す


	<innerHTML>
	HTML要素のコンテンツのプロパティ
	innerHTML()はHTMLを解析して、表示する
	例) p1.innerHTML = "<b>Hello</b>" // Hello
	　  p2.textContent = "<b>Hello</b>" // <b>Hello</b>
	※先にあった要素や文字列を上書きするため、追加したい場合は加算代入演算子などを使って追加する。


	<textContent>
	HTML要素のテキストのプロパティ

	<innerText>
	textContentと似て非なるもの。違いはあるが、使いわけは不明


	<getElementByClassName()>
	指定したクラスのHTML要素を取得し、その要素の配列を返す

	<getElementByTagName()>
	ほぼgetElementByClassName()と一緒。タグ名で要素を取得する

	<querySelector()>
	CSSセレクタを使って要素を取得する。（最初の一つだけ）
	document.querySelector(セレクタ名)

	CSSセレクタなので、指定する際、
	要素名　=>　("div")
	ID名　=>　("#list")
	クラス名　=>　(".list")　と表記する。

	※:last-childなども使える

	※query系のメソッドは、取得後にHTML側で要素が変更されても、動的に内容が更新されない。
	　処理速度も要素を取得するメソッドの中では遅い
	=>　処理速度が重要、取得後も最新の要素である必要である場合は、get系のメソッドを使う。

	<querySelectorAll()>
	querySelector()の複数ヒットするバージョン
	配列を返す
	※要素を追加する場合は、　配列[新しいインデックス].innerHTML += ""


	<appendChild()>
	指定した要素の最後に要素を追加できる（上書きはしない）
	※下に用例

	<createElement()>
	ノードを生成するメソッド
	※下に用例
	---------------------------------------------------
		// .list要素を取得
		var list = document.querySelector( ".list" );

		// 挿入用ノードの作成
		var li = document.createElement( "li" );

		// LI要素のテキストを設定
		li.textContent = "4" ;

		// 作成した要素を.list要素に追加
		list.appendChild( li );
	---------------------------------------------------


	<classListオブジェクト>
	取得した要素のクラス名の追加や変更ができる
	-add()　=>　要素に指定したクラスの追加
	-contain()　=>　要素に指定したクラスを含むかの論理値を返す
	-remove()　=>　要素から指定したクラスを削除する
	-toggle()　=>　要素に指定したクラスがあれば削除、なければ追加する
	-------------------------------------------------------------------
	// LIの最後の要素を取得
	var li = document.querySelector( ".list li:last-child" );
	// クラス名を追加
	li.classList.add( "current" );
	--------------------------------------------------------------


	<styleオブジェクト>
	取得した要素はstyleオブジェクトを介して、CSSを変更できる（Javascriptでの変更が最優先される）
	=styleプロパティを使う
	btn.style.backgroudColor = "red";

	backgroud-color => backgroundColor


	<link要素を使ったスタイルの変更>
	Linkタグで、外部のスタイルシートを読み込んでいるので、そのLinkをdisabled属性を使って変更する方法
	-----------------------------------------------------------------------
	// ボタン要素を取得し、クリックのイベントリスナーを登録
	document.getElementById( "btn-change" ).addEventListener( "click", function(){
	// disableのトグル処理
	document.getElementById( "style-change" ).disabled = !document.getElementById( "style-change" ).disabled;
	} );
	-----------------------------------------------------------------------------------
	※こんなトグル処理もある。
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
<Javascriptにおけるイベント>
<イベント>
クリック・ページ読みこみなどの動作のこと

JavascriptからHTML要素にアクセスする時、その要素がブラウザに読み込まれて解析済みである必要がある。
	
処理方法:
	<イベントハンドラ>
	イベントに対して直接処理を関連づける
	イベントを捉えて、それに反応する処理を設定できる
	1つのイベントに対して1つのイベントハンドラしか登録できない
	※DOMのプロパティの1つのような感じ

	要素の属性として、直接HTMLのタグ内に埋め込むことができる
	--------------------------------------------------
	<button type="button" class="btn" onclick="onButtonClick()">ボタン</button>

	// ボタンをクリックしたときに呼び出される関数
	function onButtonClick(){
	alert( "クリックしました" );
	---------------------------------------------------------

	script内でonclick属性に直接定義することもできる
	---------------------------------------------
	var btn = document.querySelector( ".btn" );
	btn.onclick = function(){
		alert( "1回目のクリック" );
	}
	btn.onclick = function(){
		alert( "2回目のクリック" );
	}
	※2つ目の関数が1つ目の関数を上書きする
	---------------------------------------------
	-種類（イベント名にonを付けたもの）
		onclick　=>　ボタンがクリックされたときに指定された関数を呼び出すイベントハンドラ
		onkeydown
		onload

	<イベントリスナー>
	1つのイベントに複数のイベントリスナーを登録可能

	<addEventListener()>
	イベントリスナーを登録する
	１引数: イベントのタイプ
	２引数: コールバック関数
	３引数: イベントバブリング　(省略可)

	<removeEventListener()>
	イベントリスナーの削除。
	addEventListener()と同じ引数
	-------------------------------------------
	var btn = document.querySelector( ".btn" );

	// イベントリスナーの登録
	btn.addEventListener( "click", popupAlert );

	function popupAlert(){
		btn.removeEventListener( "click", popupAlert );　//ここでイベントリスナーを削除するため、2回目のクリックでは、アラートが出ない
		alert( "クリックしました" );
	}
	---------------------------------------------------

	-イベントのタイプ（第1引数）
	<マウスイベント>
	　click　=>　クリック時
	　dblclick => ダブルクリック時
	　mouseenter　=>　要素にカーソルが入った時(子要素でも発生)
	　mouseover　=>　要素にカーソルが入った時（子要素では発生しない）
	　mouseout　=>　要素からカーソルが出たとき（子要素でも発生）
	　mouseleave　=>　要素からカーソルが出たとき（子要素では発生しない）
	　mousemove　=>　要素内をカーソルが移動しているとき
	　mousedown　=>　要素上でマウスボタンを押したとき
	　mouseup　=>　要素上でマウスボタンを放した時
	　contextmenu　=>　コンテキストメニューを表示する前に発生(右クリックで表示される操作メニューのこと)

	<フォーカス・フォームイベント>
	　focus　=>　要素にフォーカスを当てたとき（ウィンドウや入力要素などを1つ選択し、文字入力や操作を受け付ける状態にすること）
	　blur　=>　要素をフォーカスから外したとき
	　change　=>　要素の値を変更したとき
	　select　=>　テキストボックス/テキストエリアのテキストを選択した時
	　input　=>　テキストボックス/テキストエリアのvalue値が変化した時
	　reset　=>　フォームのリセットが要求された時
	　submit　=>　フォームから送信される時

	<キーイベント>
	　keydown　=>　キーを押したとき
	　keypress　=>　キーを押して文字が入力された時
	　keyup　=>　キーを離した時

	<ウィンドウイベント>
	　resize　=>　ウィンドウサイズを変更した時
	　scroll　=>　スクロールした時

	<リソースイベント>
	　error　=>　リソースの読み込みに失敗したとき
	　load　=>　ドキュメントの全リソースの読み込みが完了した時
	　beforeunload　=>　ページから遷移する前に発生
	　unload　=>　ドキュメントやリソースがアンロードされたとき、ページから遷移した時に発生（アンロードは、ロードしたものを破棄すること、ページの遷移などが当たる）

	　DOMContentLoaded　=>　HTMLドキュメントの解析後に発生（JavascriptからHTMLにアクセスする際によく使用される）
	　(loadとの違い)
	　-loadはすべての外部ファイルの読み込み完了後に発生
	　-DOMContentLoadedは外部ファイルの読み込みを待たず、HTMLドキュメントの読み込みと解析が完了した時点で発生

	<CSS animationイベント>
	　animationstart　=>　CSSアニメーションが開始したとき
	　animationend　=>　CSSアニメーションが終了したとき
	　animationiteration　=>　CSSアニメーションが繰り返されたとき

	<CSS transitionイベント>
	　transitionstart　=>　CSSトランジションが開始（遅延後）したとき
	　transitioncancel　=>　CSSトランジションがキャンセルされたとき
	　transitionend　=>　CSSトランジションが終了したとき
	　transitionrun　=>　CSSトランジションが開始（遅延前）したとき　


	-コールバック関数（第2引数）
	addEventListener()の引数に指定したコールバック関数は、Eventオブジェクトを受け取るため、その引数としてevent（任意の名前）を引数にとることでそのEventオブジェクトを参照できる

	event.typeプロパティはイベントの種類

	Event.currentTargetプロパティはイベントが発生した要素を参照する
	=>どの要素のイベントリスナーから呼ばれたか分からなくても（関数は別で定義している時）イベントが発生した要素にアクセスできる
	---------------------------------------------------------------
	var btn = document.querySelector( ".btn" );
	var box = document.querySelector( ".box" );

	// イベントリスナーの登録
	btn.addEventListener( "click", function (event) {
		box.innerHTML = event.type + ":" + event.currentTarget.value;
	} );
	--------------------------------------------------------------
	thisキーワードは、ターゲットの要素を指す

	-イベントバブリング(第三引数)
		・イベントが発生した要素から親要素へのイベントの伝播すること
		=>　バブリング
		・ルートからイベントが発生した要素に伝播すること
		=>　キャプチャリング

		この引数では、実行フェーズを真偽値で指定する
		false(初期値):　バブリングフェーズ
		true:　キャプチャリングフェーズ

		イベントは発火したとき、その要素から親要素に伝播して親要素から帰ってくる
		バブリングフェーズでは、子要素の実行、親要素の実行の順
		キャプチャリングフェーズでは、親要素の実行、子要素の順

		windowオブジェクトまで、イベントは遡る
		=>親要素に同じイベントに対するイベントハンドラがあると実行される

		<event.stopPropagation()>
		イベントの伝播をそもそもしない
		（イベントに対する関数の中で記述する）

		stop.Propagation()使用時、
		キャプチャリングがfalseの場合、子要素のみ実行
		trueの場合、親要素のみ実行
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～



～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
<Error>
<例外処理＞
エラーの詳細情報を出力したり、発生したエラーをリカバリーして別の処理を行ったりするための仕組み。

Javascriptでは、[try catch文]を使う

try{

	tryブロックで例外が発生すると、そこで処理は中断し、catchブロックに処理が移る

}catch(Errorオブジェクトを暗黙に受け取る){

	console.log(error)で出力できる

}finally{

	最後に必ず実行される(エラーがあってもなくても)
	省略可
}

<Errorオブジェクト>
エラーの詳細な情報を持っている
console.log()などで出力可
第1引数は、エラーに関する文字列情報

<throw>
ユーザー独自の例外をerrorオブジェクトに登録するためのメソッド

throw文は、Errorオブジェクトのインスタンスを受け取って、catch文に渡す。

try文の中で、
throw new Error("例外が発生しました")　みたいにインスタンスを生成
(Errorオブジェクトの第1引数は文字列　=>　error.messageプロパティに格納)

<ビルトインエラー>
標準組み込みのエラー

	・ReferenceError
	存在しない変数や関数が参照されたときに発生する。
	・SyntaxError
	構文に従っていないコードが解釈されたときに発生する
	・TypeError
	変数や引数の型が有効ではない場合に発生

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～



<メソッドチェーン>
ドット記法を使ってメソッド後にメソッドを複数つなげること
できるものとできないものがある

<ユーザーエージェント>
ユーザーエージェントとは、あるホームページにアクセスしたときに伝える、自分自身の情報のことです。利用しているOS（WindowsかMac OS）やブラウザ、スマートフォンの機種などの情報を伝えます。

<viewport>
コンテンツを表示する領域（ウィンドウ）


<クロスブラウザ問題>
ブラウザ毎に仕様が異なる問題

<apply()>
ある関数に引数を渡すに当たって、その関数の引数の形に合わせて引数を渡すのは面倒なので、Apply()メソッド使って渡す。
例)var list = [1,2,3]
max(1,2,3) => max.apply(null, list)
これで済む

第1引数はapplyメソッド内でのthisの参照先を指定する

call()メソッドとの違いは、第2引数以降の渡し方が配列かどうかだけ。




<関数の返値>
return指定なしの場合undefined

<関数定義前の行での使用も可能>

<無名関数>
１．関数を変数代入時
var func = function(){:::};
２．即時実行関数(一回しか使わないときの処理)
( function(){:::})();
目的は様々だけど、スコープの制限にも使われる
(変数スコープは関数なので)

<クロージャ>
---------------------------------
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2)); // 7 と表示される
console.log(add10(2)); // 12 と表示される
-------------------------------------------
まずある関数に内包された関数はその親関数のプロパティを参照できる（これはグローバル関数の参照ができるのとおなじ感じ)
例)makeAdder()の引数xを、無名関数は参照できる

次に、add5に格納された値は、makeAdder()の返値であるfunction(y)である。そして、console.log()でfunction(y)に引数を与えて出力している。

javascriptの特徴として、内包された関数はその作成された環境を一緒に記録している。（=クロージャしている）

そのため、一見add5には返値のfunction(y)しか入っておらず、xは参照できないように見えても、その関数の作成された環境であるmakeAdder()をfunction()は記録しているので、function(y)はxを参照できる。

要は、関数が一つのクラスみたいになっている感じかな(感想)

<再帰関数>
自分自身を呼び出す関数のこと
-------------------------------
function loop(x){
if(x>20) return; //再起関数終了条件
console.log(x);
    loop(x + 1); //再起呼び出し
}
loop(1); //1~20出力
----------------------------------

<短絡演算子>
&& と || と !!

&&は論理演算子であって、演算としては左側のオペランドがfalseの場合右オペランドは確認しない（必要がないから）
つまり、以下のように使える
-------------------------------------
/\W/.test(password) && alert('無効な文字が含まれています')
// `\W`がパスワードに含まれていた場合のみ`alert`する
// 含まれていない場合は無視される
----------------------------------
const foo = hoge || huga;
// `hoge`がある場合はそれを代入する。`huga`は無視される
// ない場合は`huga`を`foo`に代入する
-----------------------------------
!!hoge
// 一度`!`で、真偽値にしたあと、また`!`で逆転してしまったのを戻している。（値をboolean型に変換している）
// ↓と同じ
hoge = hoge ? true : false;

<return>
返値の指定の他にメソッドの終了を命令できる
if return; // undefinedを返す


<正規表現>
特定の文字を見つけ出すための機構
リテラルは/で囲む。
メタ文字の特殊な意味を使う。

var pet = /a.*e/
=>始めがaで途中何があるか分からないが最後がeの文字列

-メタ文字
	・量指定子(最大数にマッチするから注意)
	. => 改行以外の1文字にマッチ
	* => 直前文字が0回以上繰り返しにマッチ
	+ => 直前文字が1回以上繰り返しにマッチ
	? => 直前の文字の0回か1回にマッチする(なんなら単語の途中で切ってマッチすることもある
	例)　/se?/ => she - s, see - se, sea - se
	{m,n} =>直前の文字のm回以上n回以下の繰り返しにマッチ
	{m} => m回の繰り返し
	{m,} => m回以上の繰り返し

	・オプション
	g => 複数マッチ。マッチした全ての文字を配列で返す。
	i => 英字の大文字、小文字を判断しない
	m => 複数行に対応したマッチ。複数行で行頭(^)と行末($)が有効になる

	・アンカー(文字列中の位置にマッチ)
	^ (キャレット) => 行頭にマッチ。複数行検索の場合は、各行頭もマッチ。[]内では補集合を表わすので注意
	$ (ダラー) => 行末にマッチ。複数行検索の場合は、各行末もマッチ。
	\b => 単語の区切りにマッチ。単語の区切りは\Wと一緒。
		　しかし、\bの場合は区切りは出力されない
	\B => 単語区切り以外の文字にマッチ。
		　例)　man => /\Ba/ => a
	X(?=Y) => Xの後ろにYが続く場合のみマッチ。
	X(?!Y) => Xの後ろにY が続かない場合のみマッチ。

	・文字クラス
	[] => ブラケットで囲んだ1文字以上の集合を文字クラスという。
	そして、文字クラスをパターンに使うと、文字クラス内のどれか1文字に当てはまる文字があればマッチする。
	文字クラスの中ではメタ文字も普通のリテラルとして扱われる
	ｰ文字クラス内でハイフンを使うと範囲指定
	例)[a-z], [0-9],[a-zA-Z]
	[^] => ブラケットに含まれない任意の１文字にマッチする(補集合)
	\w => アンダースコアを含む英数字1字にマッチ
	\W => アンダースコアを含む英数字以外の1字にマッチ
	\d => 数字の1字にマッチ
	\D => 数字以外の1字にマッチ
	\s => 空白文字にマッチ
	\S => 空白文字以外にマッチ

※文字集合の中でメタ文字をリテラルとして使いたい場合、\を付けてエスケープする。

-match()メソッド
文字列.match(パターン)
返値：配列のインデックス0に入っている

例)
//　match()メソッド
var pat = /a.*e/;
var str = "abcdefg";
var ret = str.match(pat);
console.log(ret[0]); // abcde

//g　メタ文字
"ABCDE".match(/./g);
=> ["A","B","C","D","E"]


-(X)で囲う
括弧で囲んだパターンがマッチした場合、その文字列をRegExpオブジェクトに記録する
記録を呼び出す方法：RegExp.$1, RegExp.$2のように、括弧で囲んだグループを左から順番に呼び出せる
後方参照も可能
例)
--------------------------------
"After all, tomorrow is another day.".match(/^(\w+)/);
RegExp.$1// "After"
--------------------------------
var str = "after all, tomorrow is another day.";
str.replace(/^(\w)/, RegExp.$1.toUpperCase());
=> After all, tomorrow is another day.
※replace内であればRegExpを省力できる
------------------------------------

-(?:X)で囲う
グループ化して、RegExpに記録するが、後方参照を行わない
(グループ化の際、後方参照を可能にするように記録すると少し処理が必要のため)

-パイプを使う
| パイプの前後にある正規表現のどちらかにマッチする
X|Yであれば、XかYのいずれかにマッチする。
gオプションを使うとどちらの選択もマッチするようにできる。

<RegExpオブジェクト>
正規表現を表わすオブジェクト

<後方参照>
検索パターンの中で前でキャプチャーした文字列を参照すること

<replace()>
第一引数のパターンにマッチした文字列の一部または全部を第二引数の文字列もしくは関数で置き換えた文字列を返す。
------------------------------------------------
var str = "after all, tomorrow is another day!";
str.replace(/^(\w)/, function($1){return $1.toUpperCase();});
//"After all, tomorrow is another day!"
-------------------------------------------

<search()メソッド>
引数に渡したパターンにマッチした場所のインデックスを返す。

<split()>
指定した区切りパターンで、文字列を分割して配列を返す。
第一引数に区切り文字を指定
第二引数に分割数の指定
例)
"One,Two,Three".split(",");
=> ["One","Two","Three"]

"One Two Three".split(/\s/, 2);
=> ["One","Two"]

※joinの逆メソッド

<test()>
文字列がマッチするかの真偽値を返す
（文字列が必要な場合はmatch()）



<forの入れ子の処理数を減らす>

-各配列の要素の種類とその個数をカウントするオブジェクトを作り、それを比較する
　各要素をそれぞれ一個ずつ比較せず、カウンタ同士を比較するから、処理が累乗にならない
-------------------------------------------------
function same(arr1, arr2) {
 if (arr1.length !== arr2.length) {
   return false;
 }　//長さチェック

 let frequencyCounter1 = {};
 let frequencyCounter2 = {};

　//カウンター生成
 for (let val of arr1) {
   frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
 }

 for (let val of arr2) {
   frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
 }
-----------------------------------------
 //オブジェクト[]で、プロパティを作成
 （各要素が何個ずつあるかのカウンターオブジェクト生成）

{ '1': 1, '2': 2, '3': 1 } //元の配列[1, 2, 3, 2]
{ '1': 1, '4': 2, '9': 1 } //元の配列[9, 1, 4, 4]

-----------------------------------------
 //オブジェクト同士を評価
 for (let key in frequencyCounter1) {
   if (!(key ** 2 in frequencyCounter2)) { //まず値が存在するか
     return false;
   }
   if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {　//その頻度が同じか
     return false;
   }
 }

//console.log(frequencyCounter1);
//console.log(frequencyCounter2);
 return true;
}

//console.log(same2([1, 2, 3, 2], [9, 1, 4, 4]));

---------------------------------------------------------

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～＾
<CSS>
	<基本>
	CSSルールでは、コードの上から順に上書きしていくため、コードの下の方のスタイルがブラウザで適用される。
	-セレクタによる優先順位
	要素型セレクタ（タイプセレクタ）　=>　クラスセレクタ　=>　IDセレクタ

	<!important>
	CSSのスタイルの優先順位を最優先にする

	color: red !important;

	<!default>
	変数の値を指定する時、!defaultというフラグを付けておくことにより、変数にまだ値が割り当てられていない時のみ値を割り当てるようにすることができます。どういうことかというと、もし変数に既に値が割り当てられていた場合は再割当てされることはありませんが、まだ値が割り当てられていない場合は指定された値がセットされるということです。

	デフォルトフラグを付けることで、その変数に値がなんらか既に入っている場合、もともとの値のまま、入っていない場合、その値を代入することができる。（チェックみたいな）

	<display>
	-flex
	ある要素に定義するだけで、その直下の要素が並列になる便利なスタイルです。
	シンプルな導入であれば、CSSで「display:flex」というスタイルを指定するだけです。

		<justify-contentプロパティ>
		コンテナ内全体の主軸方向（初期値では横方向）の揃え位置を指定する
		※子要素とスペースの配置の関係
		-flex-start
		行頭寄せ、通常は左揃え（初期値）
		-flex-end
		行末寄せ、通常は右揃え
		-center
		センター揃え
		-space-between
		アイテムの間にスペースを均等に割り付け
		-space-around
		アイテムの両端にスペースを均等に割り付け

		<flex-basis>
		フレックスアイテムの主要部分の初期の寸法を設定します。
		box-sizingで設定していない限り、このプロパティはコンテンツボックスの寸法を定義します。
		flex指定の親ボックスの子要素の主要部分のサイズを指定するプロパティ

	-inherit
	親要素の値を継承する


	<align-items>
	子要素の高さ方向の寄せを指定するプロパティ
	align-items: stretch;//子要素のcontentがめいっぱい広がる
	align-items: center;//子要素の高さの真ん中にcontentが配置
	align-items: start;//上段寄せ
	align-items: end;//下段寄せ


	<overflow>
	overflowプロパティは、ボックスの範囲内に内容が収まらない場合に、はみ出た部分の表示の仕方を指定する
	-値
	visible　:　内容がボックスに収まらない場合、ボックスからはみ出して表示される（初期値）
	hidden　:　内容がボックスに収まらない場合、収まらない部分は非表示となる。内容が収まらない場合にも、スクロールバーなどは表示されない
	scroll　:　内容がボックスに収まらない場合、収まらない部分はボックスからはみ出さない。内容が収まらない場合には、スクロールバーなどが表示される
	auto　:　ボックスに収まらない内容をどう表示するかは、ユーザーエージェントに依存する。内容が収まらない場合には、スクロールバーなどが表示される
	no-display　:　内容がボックスに収まらない場合、display：none; が指定されたかのようにボックス全体が削除される
	no-content　:　内容がボックスに収まらない場合、visibility：hidden; が指定されたかのようにボックス全体が非表示となる


	<position>
	positionプロパティは、ボックスの配置方法（基準位置）が、相対位置か絶対位置かを指定する際に使用します。
	-値
	static　:　特に配置方法を指定しません。この値のときには、top、bottom、left、rightは適用されません。これが初期値です。
	relative　:　相対位置への配置となります。positionプロパティでstaticを指定した場合に表示される位置が基準位置となります。(本来表示される位置を基準に変更)
	absolute　:　絶対位置への配置となります。親ボックスにpositionプロパティのstatic以外の値が指定されている場合には、親ボックスの左上が基準位置となります。
	fixed　:　絶対位置への配置となるのはabsoluteと同じですが、スクロールしても位置が固定されたままとなります。

	top、bottom、right、left
	=>その要素がstaticで無いときに、ブロックのpositionの設定関係を参考に、それぞれ上下右左からの距離を取って配置する

	<z-index>
	z-indexプロパティは、ボックスの重なりの順序を指定する際に使用します。 z-indexプロパティは、positionプロパティでstatic以外の値が指定されている要素に適用されます。
	-値
	整数値で指定　:　重なりの順序を整数で指定します。0を基準として、値が大きいものほど上になります。
	auto　:　親要素と同じ階層になります。これが初期値です。

	<transition>
	遷移 (transition) によって、要素の2つの状態間の変化を定義することができます。
	それぞれの状態は :hover や :active のような疑似クラスで定義するか、 JavaScript を使用して動的に設定します。

	----------------------------------------------------
	/* 1つのプロパティへの適用 */
	/* プロパティ名 | 時間 */
	transition: margin-right 4s;

	/* プロパティ名 | 時間 | 遅延 */
	transition: margin-right 4s 1s;

	/* プロパティ名 | 時間 | 時間関数 */
	transition: margin-right 4s ease-in-out;

	/* プロパティ名 | 時間 | 時間関数 | 遅延 */
	transition: margin-right 4s ease-in-out 1s;

	/* 2つのプロパティへの適用 */
	transition: margin-right 4s, color 1s;

	/* 変化するすべてのプロパティへの適用 */
	transition: all 0.5s ease-out;
	---------------------------------------------------
	<時間関数>(イージング　=　アニメーションの種類のこと)
	　ease（初期値）　=>　開始時と終了時は緩やかに変化します。
	　linear　=>　開始から終了まで一定に変化します。
	　ease-in　=>　開始時は緩やかに変化、終了に近づくと早く変化します。
	　ease-out　=>　開始時は早く変化し、終了時は緩やかに変化します。
	　ease-in-out　=>　開始時と終了時は、かなり緩やかに変化します。

	-------------------------------------------------------------
	#panel-btn {
	display: block;
	margin: 10px;
	width: 60px;
	height: 60px;
	border-radius: 50%;
	background: #fff;
	opacity: 0.8;
	transition: 0.3s ease-out;
	/* ホバー時 */
	&:hover{　//疑似クラスでそれぞれの状態を指定する
		opacity: 1;
		box-shadow:0px 1px 5px 3px rgba(0,0,0,0.2);
		/* ホバー時三本線をアニメーションさせる */
		#panel-btn-icon:before{
			margin-top: -12px;　//ネガティブマージン　（top,leftでは、上と左にcontentを引っ張るが、bottom,rightは内向きにcontentが縮む）
		}
		#panel-btn-icon:after{
			margin-top: 9px;
		}
	}

	/* 3本線アイコン用プレースホルダ */　//下に説明あり
	%btn-icon {
		display: block;
		top: 49%;
		left: 50%;
		width: 24px;
		height: 3px;
		background: #252f39;
	}
	/* 3本線アイコン */
	#panel-btn-icon {
		@extend %btn-icon;
		position: relative;
		margin-left: -12px;
		transition: 0.2s;
		/* 上下のライン */
		&:after,
		&:before {
			@extend %btn-icon;
			position: absolute;
			content: "";
			left: 0;
			transition: 0.3s;
		}
		&:before {
			margin-top: -10px;
		}
		&:after {
			margin-top: 7px;
		}
	}

	/* 閉じる */
	.close {
		background: transparent !important;
		&:after,
		&:before {
			margin-top: 0 !important;
		}
		&:before {
			transform: rotate(-45deg);
		}
		&:after {
			transform: rotate(-135deg);
		}
	}
}
-------------------------------------------------------

	<％プレースホルダーセレクタ>
	Saasのセレクタの1つであり、％を先頭につける
	よく使うスタイルセットを定義しておき、必要な時に呼び出して、そのスタイルを挿入する。

	@extend %プレースホルダー名　で呼び出す

	<opacity> 
	要素の透明度を指定する

	透明度の値　0.0（完全に透明）～1.0（完全に不透明）（初期値は1）
	inherit　　継承する

	<&セレクタ>
	ブロックの親セレクタを参照し、その名称を書いたのと同じ効果

	<@import url()>
	フォントファイルなどの読み込みに使う
	　-bodyをターゲットにfont-familyで読み込んで使う

	<Saas>
	Sassは「Syntactically Awesome StyleSheet」の略です。
	SassはCSSのメタ言語というもので、簡単に言うと「CSSをさらに拡張して、より効率的に書けるようにしたよ」ということです。

		<Saasの変数>
		Saasが提供する変数。
		$bg-color: #fff
		のように、先頭が$、変数名と値を:で区切る
		色、サイズ、パスなどなんでも格納できる
		※変数が使えるようになるため、効率とデバックがしやすい
		文字列と区別しないとエラーとなる　=>　文字列内では、#{}で囲んで使う

		<map-get($map,$key)>
			$mapの中から$keyに対応した値を取得します。

			$breakpoints: (
			  sm: 768px,
			  md: 992px,
			  lg: 1200px,
			);

			@debug map-get($breakpoints, lg); //1200px
			map-merge($map1,$map2)



	<疑似セレクタ>
	おそらくthisのように、セレクタ名とは別にターゲットを指定するセレクタ

	<:last-child>
	疑似セレクタの一つ。そのターゲットの最後の子要素をセレクトする。

	<backgroud>
	transparent => 透明色に指定する（透明度ではない）

	<border-radious>
	角丸をまとめて指定する
	値:
	長さ
	楕円半径の長さを指定する（初期値は0）
	パーセンテージ
	ボーダーボックスの幅と高さに対する楕円半径のパーセンテージを指定する

	<rem>
	親要素での設定（フォントサイズの場合は、親要素でのfont-size）を1remとして、
	割合で子要素のサイズを表わす
	一番の親要素、親設定（ルート要素）につかうと初期値を表わす。

	<em>
	emは文字の高さを基準とした単位です。 emは使われている書体（フォント）や、CSSで指定している文字の大きさによって変化する相対単位です。 例えば文字の大きさを10pxにしていたなら、1emは10pxということになり、30pxを指定していたなら、1emは30pxに変化します

	<Mixin>
	Saasの機能の一つ。
	予めスタイルを定義しておき、@includeで呼び出す。
	-プレースホルダーとは異なり、関数のように引数を取ることができる
	※Mixin内に具体的な値を変数と一緒に設定すると初期値になる。
	　=>　引数無しで呼び出した時の値になる。
	-------------------------------------------------------
	@mixin box-circle( $size ){
		width: $size;
		height: $size;
		border-radious: 50%;
	}

	.box {
		@include box-circle(100px);
		background: #FF5F5F
	}

	// .box{
		width: 100px;
		height: 100px;
		border-radious: 50%;
		background: #FF5F5F; //こいつもちゃんと設定できる
	}
	-----------------------------------------------------------

<メディアクエリ>
<link rel="stylesheet" href="css/style.css" media="screen">
このコードの場合、通常のディスプレイに対して、”style.css”を適用するという事です。
つまり、ユーザーがどのような端末＝媒体でアクセスしているかは判断することができました。
しかし、大きいディスプレイと小さいディスプレイで見え方を変えたいと思った場合、媒体までしか判断ができない(条件分岐ができない)のでCSSだけではどうする事もできませんした。

媒体までしか判断できなかったメディア・タイプを拡張し”媒体の特性”まで判断できるようにしたのがメディアクエリです。

-書き方
	・htmlのheadタグの中に記述する方法
	<link rel="stylesheet" href="style.css" media="screen and (max-width:480px)">
	media=”　”のところを見てみると、screen　の後ろに何か記述されています。
	これこそがメディアクエリです。それではこれはどのような意味があるのかというと「画面サイズが480pxまではstyle.cssを読み込め」となり画面サイズ480pxまではstyle.cssに記述されているCSSが適用されます。
	---------------------------------------------------------------
	<link rel="stylesheet" href="small.css" media="screen and (max-width:480px)">　//画面サイズが480pxまでこのファイルのスタイルが適用される。

	<link rel="stylesheet" href="medium.css" media="screen and (min-width:480px) and (max-width:1024px)"> //画面サイズ480pxから1024pxまではこのファイルのスタイルが適用される。

	<link rel="stylesheet" href="wide.css" media="screen and (min-width:1024px)">
	--------------------------------------------------------------
	このように、条件別に複数のlinkタグを書くこともできる

	・CSSで指定する方法
	@media以外の所は全てのサイズで読み込まれる。
	--------------------------------------------------------
	p {
	 color:red;
	}
	@media screen and (min-width:480px) { 
	    /*　画面サイズが480pxからはここを読み込む　*/
	p { color:#ededed;}
	}
	@media screen and (min-width:768px) and ( max-width:1024px) {
	    /*　画面サイズが768pxから1024pxまではここを読み込む　*/
	p {}
	}
	@media screen and (min-width:1024px) {
	    /*　画面サイズが1024pxからはここを読み込む　*/
	}
	---------------------------------------------------------------
	ブラウザはファイルの上から下へと順番に読込HTMLに適用していきます。
	上記のソースをみて、小さい画面サイズから段々大きくなっています。

	このように小さいサイズから順々に指定いく方法を“モバイルファースト”と呼び、逆に大きいサイズから指定していく方法を“デスクトップファースト”と呼びます。

	-mixinを用いたメディアクエリ実例
	--------------------------------------
	$screen-md: 768px;  //ブレイクポイント
	$screen-md-min: $screen-md;　デスクトップの最小サイズ
	$screen-sm-max: ($screen-md-min - 1);　デスクトップの最小サイズより1小さいのが、スマホの最大サイズ

	// メディアクエリ用Minxin
	$breakpoints: (　//配列で代入
		'sm': 'screen and (max-width: ' + $screen-sm-max + ')',
		'md': 'screen and (min-width: ' + $screen-md-min + ')',
	) !default;//　事前に値が入っていないかチェック

	@mixin mq( $breakpoint: md ) {　//$breakpointというブロック変数（初期値　md）
		@media #{map-get($breakpoints, $breakpoint)} {
			@content;//　実行される場所での処理内容を表わす
		}
	}
	-------------------------------------------------------
	<@content>
	Saasの機能の一つ。
	呼び出した側の値をいれることができる。


	<cursorプロパティ>
	マウスポインターが要素の上にいるときに表示されるカーソルの種類を設定します。
	-値
	help　-　はてな付きカーソル
	wait　-　ローディングマール
	crosshair　-　十字マーク
	not-allowed　-　禁止マーク
	zoom-in　-　虫眼鏡マーク
	grab　-　手のひらマーク
	pointer　-　指さしマーク
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～


<Webフォント>
Webサーバからフォントデータを読み込み、ページ内でそのフォントを利用できるようにします。
※Google Fontsなどがある
※英語のみのフォントは複数使っても、処理にさほど影響しないが、日本語はその多さ故に、複数使うと処理に影響を与える可能性がある

<スライドメニュー>
ハンバーガーメニューをクリックしたときなどに展開される各メニューの一覧
=>スライドインしてくるメニュー
メニュー自体は、right: 100%などで左側に隠しておく

<パララックス>
webページのデザイン様式の一つ。
スタイルを前面後面で異なるものに設定することで、立体感や奥行きを表現することができる。
そのため、ストーリー性などを強めることができるが、読み込みに時間がかかったり、ブラウザチェックに時間がかかるといったデメリットもある。

<MITライセンス>
比較的、制限の緩いライセンス。著作権表示は必要だが、改変、再配布、商用利用など制限なく利用できる。

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
<jQuery>
DOMを簡単に操作する手段の提供と、イベントやアニメーション、Ajax、といいた幅広い機能を備えたJavascriptのライブラリ。
MITライセンスのもと、オープンソースで提供されている。

-主な特徴
・クロスブラウザに対応
・DOMの操作と変更
・プラグインによる拡張
・Ajax対応
・無料で利用可能

ファイル名　=>　jquery-バージョン番号.min.js

利用方法１
jQueryファイルを必要な作業ディレクトリにコピーし、そのファイルをscriptタグで読み込む。

利用方法２
CDNで配信されているjQueryを利用する
	<CDN　(Content Delivery Network)>
	高速にコンテンツを配信するための仕組み。
	Google、CDNJS、jsDeliverなどの種類がある。

CDNで配信されているjQueryは、scriptタグにそれらｒのURLを指定するだけで利用できる。


-記述方法

CSSセレクタを使って、HTML要素を取得する
ドット記法で繋げたメソッドが利用できる

jQuery("セレクタ").メソッド(引数);

もしくは、

$("セレクタ").メソッド(引数);　//$でjQueryを省略

セレクタ名の書式
	-基本のセレクタ
	$("要素")　//要素
	$("#ID名")　//ID属性を持つ要素
	$(".class名")　//クラス属性を持つ要素
	$("A, B") // A and B
	$("*") // 全てのセレクタ

	-階層セレクタ
	$("親要素　子要素")　//親要素内にある子要素
	$("親要素>子要素")　//親要素直下にある子要素
	$("要素A + 要素B")　//要素Aの次にある要素B
	$("要素A~要素")　//要素Aの後にある要素

	-フィルターセレクタ(疑似クラス)
	$("要素:first")　//先頭の要素
	$("要素:last")　//末尾の要素
	$("要素:not(セレクタ)")　//指定したセレクタを除外した要素
	$("要素:even")　//偶数番目の要素
	$("要素:odd")　//奇数番目の要素
	$("要素:eq(インデックス)")　//インデックスに指定した要素
	$("要素:lt(インデックス)")　//指定したインデックスより前の要素
	$("要素:gt(インデックス)")　//指定したインデックスより後の要素
	$(":header")　//h1、h2などのヘッダー要素
	$(":animated")　//アニメーション中の要素
	$(":hidden")　//非表示要素とidden属性のinput要素
	$(":visible")　//表示されている要素
	$("親要素>子要素:first-child")　//親要素直下の最初の子要素
	$("親要素>子要素:last-child")　//親要素直下の最後の子要素
	$("要素:only-child")　//特定の要素が1つだけ含まれている要素(特定の要素の唯一の子要素である等)
	$("要素:contains(テキスト)")　//テキストに指定した文字列を含む要素
	$("要素:has(セレクタ)")　//指定したセレクタを持つ要素
	$("要素:empty")　//空要素
	$("要素:parent")　//子要素やテキストを持つ要素

	-属性フィルター(属性　=　attribute)
	$("要素[attribute]")　//指定した属性を持つ要素
	$("要素[attribute=value]")　//指定した属性値を持つ要素
	$("要素[attribute!=value]")　//指定した属性値を持たない要素
	$("要素[attribute^=テキスト]")　//属性値が指定した文字列から始まる要素
	$("要素[attribute$=テキスト]")　//属性値が指定した文字列で終わる要素
	$("要素[attribute*=テキスト]")　//属性値が指定した文字列を含む要素
	$("要素[selector1][selector2]...")　//指定したセレクタフィルターをすべて満たす要素



-メソッド
　-jQueryのメソッドはほとんどがメソッドチェーンに対応
	すべてではないが、jQueryオブジェクトを返すメソッドはつなげられる


<fadeOut(ミリ秒)>
ミリ秒かけて消える

<ready()>
HTMLの読み込み後に実行(DOMの操作可能になってからの処理の実行)=DOMContentLoaded
$(document).ready(function(){
	・・・
});

もしくは、

$(function(){　//$()でjquery(document).ready()を省略
	
});

画像の読み込みを待ちたい場合は、
$(window).on("load", function(){
	
});

<on()>
javascriptのイベントハンドラを実装するためのメソッド

$(セレクタ).on(イベント名,コールバック関数);

イベント名のところを複数指定すると、指定したどのイベントが発生しても実行する

第一引数をオブジェクトにすることで、イベント毎に別々の処理を記述できる
オブジェクトはキーにイベント名、値にコールバック関数を指定

$(".btn").on({
	"mouseover" : function(){

	},
	"mouseleave" : function(){

	}
} );


<animate()>
CSSと同じアニメーション効果を実装する
CSSと違い、様々なタイミングで実行でき、コールバック関数も指定できる
(CSSは:hoverなど、疑似クラス指定でしかアニメーションを指定できなかった)

$(セレクタ).animate( {"プロパティ名 : "値"}, 遅延, イージング, コールバック関数);

プロパティ名　:　変化させたいCSS名(backgroundColorなど)
値　:　そのCSSの値(変化完了後の状態)
遅延　:　実行のタイミングをどれだけ遅らせるかの値
イージング　:　アニメーションの種類
		(最初は遅くて、後から速くなるアニメ)
		(跳ねるようなアニメ)
		(落下するようなアニメ)
コールバック関数　:　アニメーションの処理が終わった後に実行させたい関数を指定


<toggleClass(クラス名)>
classlist.toggle()と同様、クラス名がなければ追加し、あれば削除する

<next()>
兄弟要素の中で次の要素をセレクタとする
(引数には、変更後のセレクタを指定できるが、元のセレクタにとって、その指定要素が次の要素でない場合、next()は何も指定しない)

※<prev()>
	兄弟要素の自分の前を指定する（挙動は同じ）

<div class="box">
  <h1>h1要素です</h1>
  <p>p要素です1</p>
  <h2>h2要素です</h2>
  <p>p要素です2</p>
</div>

$(function() {
 
  // 自要素の次を指定
  $('h1').next().css('color', '#c00');
});　//pタグの一つ目が変化する


<nextAll()>
セレクタの次以降の兄弟要素にアクセスできる
引数無し　=>　次以降の兄弟要素全て
セレクタ指定　=>　元のセレクタの次以降の兄弟要素であれば、次の要素でなくても指定できる

※<prevAll()>
	兄弟要素の自分の前以前を指定する（挙動は同じ）

<siblings()>
兄弟要素の中で自分以外を指定する
引数無し　=>　自分以外全て
セレクタ指定　=>　兄弟要素の中で、自分以外でそのセレクタに該当する要素を指定

<slideToggle()>
表示・非表示を切り替えるメソッド
スライドして表示・非表示する




