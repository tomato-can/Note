<Javascript>
すべてのファイル内容を読み込んでから実行する(javascriptファイルにおいては)（HTMLなどとの連携は関係なく）
=>後に関数の記述をしてもOK、ローカル変数とグローバル変数の上書き関係も定義前後関係がない

Javascriptはデータ型の指定なし

Javascriptのバリデーションはブラウザに依存するため、サーバサイドでバリデーション必要

複数のscriptタグを1つのHTMLに持つことが出来る


<addEventListener()>
イベントを受け取る
１引数: event
２引数: function()

想像以上にややこしい関数
引数のところ

<イベント>
クリック・ページ読みこみなどの動作のこと

<イベントハンドラ>
あるイベント発生時に、処理を行う関数

<モーダルウィンドウ>
ポップアップなどのウィンドウ

<メソッドとプロパティ>
Javaでいうメソッドとフィールド

<document>
現在のページを示す変数

<write()>
文字列のHTML出力

<console.log()>
コンソールのログ出力
その他).debug (出力レベルが高い) .info, .warn, .error


<DOMContentLoaded>
イベントの1つ（ページ読み込みの完了）

<window>
ブラウザを示す変数
document: HTMLプロパティを持つ
window: documentを含め、アラートやURLなど、ブラウザにおけるプロパティを持っている


<scriptの属性>
・src
・async = 非同期のスクリプト読み込み
		 実行はHTMLパーズの完了後とは限らない
		 Google Analyticsなど、DOMに関係ないものに使う
		 <script async></script>
・defer = 非同期読み込み
		 実行はHTML解析の後
・charset

<レンダリング>
jsはコードを上から順にHTML解析を行う
UI上scriptはbodyの最後に書くことが望ましい
（jsを先にダウンロードしても実行は最後のため、遷移体感時間に影響しない）

<HTMLパース>
HTML解析のこと

<var>
変数宣言メソッド
複数同時宣言可能　var a,b,c
スコープは変数の中　(｛｝ブロックではない)
通常、関数内からグローバル変数の参照可能。しかし、グローバル変数と同名のローカル変数を関数内に宣言する場合、関数内においては、そのローカル変数が宣言前であっても、その変数名に入っている値はundefined(つまり、はローカル変数として扱われる)

例)
var x = 0;

function func(){
console.log(x);
var x = 1
};

func();　//undefined
-----------------------------
var x = 0;

function func(){
console.log(x);
};

func(); // 0


<let>
機能はvarと同様
スコープがブロック単位

<const>
定数宣言

<文字列型>
\ は以降に改行以外これない
＝\を使うと複数行に単文の文字列入力が出来る

<エスケープシーケンス>
\を付けることで文字列内で特殊入力が可能
\\ => \, \" \" => "", \n => 改行, \t => タブ

<Number()>
INT型変換

<parceFloat()>
FLOAT型変換

<指数表記>
○○の10乗という表記法
例)　3e+2 => 300 // 3を+2桁分ずらす
　　 1e-3 => 0.01 // 1を-3桁分ずらす
※プラスは省略可能

<boolean>
false(0, null, undifined, 空文字)

<null>
0, falseとして動く

<オブジェクト型>
Rubyのハッシュ的な感じ
参照渡し

-プロパティの呼び出し
	=>　ドット記法と連想配列記法
	ドット配列　obj.name
	連想配列　obj["name"]

	※プロパティ名にハイフンや空白は使えず、使う場合はプロパティ名をクォーテーションで囲む(この場合、呼び出しは連想配列記法しか無理)

-プロパティの追加
	ドット記法で普通に追加
	obj.number = 1234; //numberプロパティの追加

-プロパティの削除
	=> deleteメソッド
	delete obj.number

-メソッド
	オブジェクト内の関数のこと
	プロパティの値として登録される

-オブジェクトの作成方法

	（オブジェクトリテラル）
	ブレス{}で囲んで作成
	そして、{}内にプロパティとメソッドを記述できる
	var obj = {
		name : "OO", //カンマで区切る
		age : 10,
		method : function(){}
	};
	※インスタンスを一つずつ作るイメージ

	（関数とnew演算子）
	javascriptではコンストラクタの専用構文はなく、new演算子に呼ばれる関数をコンストラクタと呼ぶ。
	またコンストラクタ作成にはthisキーワードが必須であり、thisを付けない場合、そのプロパティはそのコンストラクタに属さない。(普通の関数内変数として隠蔽される　=　インスタンスに反映しない)
	(コンストラクタは関数と区別するため、名前の始めを大文字にする)
	function Person(name){
		this.name = name;
		this.greet = function(){
			console.log("Hello, My name is" + this.name);
		}
	}

	var obj = new Person("NAME");
	※クラスとは別っぽい?

	<thisキーワード>
	オブジェクト内包されていれば、そのオブジェクト
	内包されていなければ、windowオブジェクト
	(windowもオブジェクトなのだろう)

-オブジェクトの種類
	-ビルトインオブジェクト(組み込みオブジェクト)

		・標準ビルトインオブジェクト
			Javascript標準仕様のオブジェクト
			undefinedプロパティやparceFloat()メソッド、Mathコンストラクタなどが属する。

		・ブラウザオブジェクト
			HTML要素を操作するためのオブジェクト

		・DOMオブジェクト
			ブラウザが提供するオブジェクト
			このオブジェクトを通じて、現在のページのURLや履歴にアクセスすることができる

<標準ビルトインオブジェクト>
-Object 全てのオブジェクトの元となる基本オブジェクト
-Function 関数を作成するためのオブジェクト
-Boolean 論理値を扱うためのオブジェクト
-String 文字列操作をするためのオブジェクト
-RegExp 正規表現を表わすオブジェクト
-Array 配列を扱うためのオブジェクト
-Number 数値を扱うためのオブジェクト
-Math 数学計算を行うオブジェクト
-Date 日付や時刻を扱うためのオブジェクト

これらのオブジェクトの使い方
１．コンストラクタとして、new演算子でインスタンスを作り、プロパティにアクセスする

２．オブジェクトリテラルやキーワードを使う(実行速度が速い)

配列の作成　x = new Array(); <=> x = [];
論理値の作成　x = new Boolean(); <=> x = false; ( デフォルトのプリミティブ値はfalse)
関数の作成　x = new Function(); <=> x = function(){};
数値の作成　x = new Number(); <=> x = 0; (デフォルトのプリミティブ値は0)
オブジェクトの作成　x = new Object(); <=> x = {};
正規表現の作成　x = new RedExp(); <=> x = /(?:)/;
文字列の作成　x = new String(); <=> x = "";

Javascriptでは、プリミティブ値も必要時にオブジェクト変換されて、プロパティやメソッドにアクセスできる(自動型変換機能)


<プリミティブ値>
値一つだけを持つ基本の型

<配列>
var array = [1,2,3];
	array[1];

<typeof()>
データ型を返す(初期値undefined)

<型の自動変換>
プリミティブ型に"."を付けると一時的にオブジェクトになる
	=>str.length => Stringオブジェクトのlengthプロパティのアクセス

<slice()>
第1引数で指定した要素から第2引数で指定した要素までを返す。元の配列に影響なし。

<join()>
配列の各要素を指定の文字列で連結し、結果を文字列で出力

<Array()>
引数の数のインデックスを持った配列を作成(undefined)

<＋>
文字列の数字につけると文字列を数値に変換
例)　5 + +"3.25" => 8.25
　   +null, +false => 0
　   +true => 1
     変換不可　=>　NaN

<===>
厳密等値（数値が一致かつ、データ型が一致）
1 == "1" => true, 1 === "1" => false
※==，!=は型変換を行ってから比較

<!==>
厳密不等値（数値が一致しないかつ、データ型が一致しない）
1 != "2" => true, 1 !== "2" => false

<toString()>
引数の進数に変換

<ビット演算子>
2進数の集合演算
ｰ論理積　&
 - 1000 & 1001 => 1000
-論理和　|
 - 1000 | 1001 => 1001
-排他的論理和　^
 - 1000 ^ 1001 => 1
-否定　~
 - ~1000 => 0111 ※32bitと64bitがある
ｰシフト　<< >>
2進数を右オペランド分桁をずらす（1桁で2のnで変化する）
 - 1000<<1 => 2000
 - 1000>>1 => 500

<ゼロ埋め右シフト>
-1000>>>1
2進数の桁をまるごと右へスライドして、上位ビットを0で埋める

<**>
累乗

<三項演算子>
X = a>b ? a:0;
?の前の条件式が、trueなら:の前のオペランド、falseなら:の後のオペランドが返される

<switch>
switch(x){
	case 0 :
	case 1 :
		break;
	default:
}

<ゼロパディング>
0を付けて数値の桁数を合わせる

<スクリプト言語とインタプリタ言語>
スクリプト言語 = 明確な定義はない（比較的簡単に書ける言語の総称)
インタプリタ言語 = コンパイル不要の言語
※スクリプト言語のほとんどはインタプリタ言語

<DOM>
Document Object Model
HTML要素をブロック要素として扱う仕組みのこと

<ロールオーバー>
マウスを要素に重ねた時(マウスオーバー)cssを変化させる現象

<スニペット>
よく使うコードを登録して呼び出す機能

<フォーク>
分岐を意味する(元ソースから分離して別バージョンを作る)

<デバック>
プログラム内のおかしな場所、またその改修のこと
console.debugはログ出力レベル(verbose)で出力される
normalでは出力されない

<コンソールパネル>
デベロッパーツールの1つ。プログラム実行可能。
[Enter] = 実行, [shift] + [Enter] = 改行

<ブレイス>
{}のこと

<ブラケット>
[]のこと

<コメントアウト>
//
/**/

<ランディングページ>
LP。　1つの商品やサービスを売るための一枚の長いWEBページ

<非同期処理>
HTMLパース中に、JSのダウンロードを行うことで遷移を早くする技術
ｰ処理内によそからデータが必要なものがある場合、そのリクエスト結果が帰ってくるまでの間他の処理を先に行い、必要なデータがそろった時点で実行すること。
コールバック関数との組み合わせが強力

<コールバック関数>
関数の引数として渡される関数のこと
関数の引数に渡す関数（=コールバック関数）は無名関数か、関数名の（）無しで渡す。
関数に()を付けると実行してしまうため、コールバック関数には()を付けない
--------------------------------------
function exec(callbackFunc, MSG){//コールバック関数に引数を渡したい場合は親関数の第二引数として渡して、処理内で実行する
	callbackFunc(MSG);
};
var myCallBack = function(MSG){
	console.log(MSG);
};

exec(myCallBack, "hello");


<HTML内に<script>>
HTTP通信を減らせる

<リテラル>
変数と定数以外のデータ

<UML>
設計図表記の規格の1つ

<for>
処理の順番(初期化式->条件式->ブロック内の処理->増加文の評価)
for (var i = 1, j = 3; i<=3; i++, j--){
	処理
}

<dlタグ>
「DL」とは「definition list（定義）」の略で、定義リストを表すタグです。
定義リストは<dl>タグで範囲で表し、定義する用語（Definition Term）を<dt>タグで、用語の説明（Definition Description）を<dd>タグで表します。
この定義語と用語の説明のセットは、複数表記することが可能です。
<dl>
<dt>用語</dt>
<dd>用語に対する説明</dd>
</dl>


<!hoge による判定>
if (!hoge) { ... }
この条件が true になるのは上の表から分かるように
null, undefined, 0, 空文字(''), false になります.
※注意点
数値を受け取るかどうかに気をつけてください.
何故なら 0 の場合も true になっちゃうので 0 を渡した時に
意図しない挙動をする可能性があるからです.

<value>
そのHTML要素が持つ入力内容

<do while>
do{
	処理
} while(条件);
全てのループにおいて処理が先
※条件式の範囲に注意


<カスタムプロパティ>
CSSにおいて、よく使うcolorなどを代表的な一つの変数に代入しておく記法によって、作られるプロパティ
:root{
	--main-bg-color: brown;
}

<with>
with( Math){
	console.log("最小:" + min(a,b));
};
Mathオブジェクトのmin()メソッドをオブジェクト名なしで呼び出す

<リスト>
数値や文字列など複数の値を並べた構造のこと
リストを変数に代入したものを配列という
書き方：ブラケット[]とコンマで書く

配列の値は要素と言われる

<配列>
作成方法：
１.リストの代入　[1,2,3]
２.Array()オブジェクトの利用
	引数1つの場合は、インデックスの数
	2つ以上の場合は、その数字を要素に取る配列
	ｰvar list = Array(1,2,3)// list[1] => 2
	-var list = Array(1)// list[0] => undefined
ー var list = new Array(1,2,3);

３.[]リテラルを使って作るのが基本
	var list = []//初期化　要素数も要素もリセット
	var list = [2]　リテラルを使うと一つの要素でも配列を作れる

ー要素に変数・式を用いることもできる
var y = 1;
var list = [y, y*2]

-メソッドの追加
var list = [];
Object.prototype.meth = funtion(){}

<forの種類>

<for in>
for ( 変数　in オブジェクト){
	処理
}

オブジェクトの各要素にアクセスして、プロパティ名を一個ずつ取り出す
(プロパティの順序を保証しない)
(メソッドにもアクセスする)

※配列での使用も可能
配列の場合は基本インデックス
しかし、カスタムプロパティやカスタムメソッドもループ処理対象になるため、for文の方が無難
※ここでのカスタムプロパティやカスタムメソッドはプロトタイプチェーン上のプロパティやメソッドのこと。

ｰfor of
変数に要素そのものを代入する


<Object>
全てのオブジェクトのもとになる基本のオブジェクト

※new演算子はメモリ上に記憶場所を確保して、オブジェクトを作成し、ポインタを返す。
　そのポインタが格納された変数がインスタンス、
　メモリ上で作成されたオブジェクトをインスタンスオブジェクトという。
また、Number/string/Booleanはインスタンス==オブジェクト


----------------------------------------
オブジェクト[プロパティ名]　ブラケットでプロパティにアクセス

※Javascriptの場合、それでプロパティの生成もできる
--------------------------------------

-コンストラクタプロパティとインスタンスプロパティ
	・コンストラクタプロパティ　=　コンストラクタに属するプロパティで、インスタンスからは呼び出せないもの。
	※プリミティブ値が一時的に変換されるのは、オブジェクトそのものなので、こっちのメソッドが使える。

		<Object.keys()>
		指定したオブジェクトのすべてのプロパティ名を配列で返す
		プロトタイプチェーンをさかのぼらない

		<Object.setPrototypeOf()>
		プロトタイプを設定する
		(言語開発をするようなものなので、避けるべき)

		<Object.values()>
		指定したオブジェクトの値を配列として返す。

		<Object.getOwnPropertyNames()>
		列挙不可のプロパティを含めて、調べることができる。

	・インスタンスプロパティ　=　インスタンスの作成が必要なプロパティ

		<constructorプロパティ>
		インスタンスのプロトタイプを作ったObject関数の参照を返す

		<hasOwnProperty()>
		オブジェクトに指定したプロパティが継承されたものではなく、自身に直接属するプロパティかどうかを論理値で返す。(プロトタイプチェーン上ではない)
		---------------------------------------
		const object1 = new Object();
		object1.property1 = 42;

		console.log(object1.hasOwnProperty('property1'));
		// expected output: true

		console.log(object1.hasOwnProperty('toString'));
		// expected output: false

		console.log(object1.hasOwnProperty('hasOwnProperty'));
		// expected output: false
		----------------------------------------------

		<isPrototypeOf()>
		オブジェクトが指定したオブジェクトのプロトタイプチェーンに含まれるかを論理値で返す
		※自分が他のオブジェクトのプロトタイプチェーンに存在するか(=自分が親かどうか)

		<propertyIsEnumerable()>
		指定したプロパティが列挙可能かを論理値で返す。

		[Enumerable]の値とは、列挙をする時に意図的に列挙できないように設定するもの。
		組み込みオブジェクトのプロパティは意図的にfor文とかで列挙しないようにしてある。

		<toLocaleString()>
		toString()を呼び出す

		<toString()>
		オブジェクトから文字列情報を返す

		<valueOf()>
		指定したオブジェクトの値を返す


	<Object.prototype>
	Objectはベースとなる特殊なオブジェクトで、すべてのオブジェクトはObject.prototypeのプロパティとメソッドを継承する。
	-String.prototype.speak = function(){};とすることで、Stringオブジェクトのコンストラクタをカスタムできる。
	=> 全てのインスタンス間でメソッドを共有できる(メモリの圧迫を押さえる)

	※ちなみにFunctionもオブジェクトなので、基本的になんでもオブジェクト。
	※prototypeプロパティとは、そのコンストラクタとその子要素が共有して持っている、データの格納庫。みんなで同じものを共有している。

	<記述>
	Object.prototype = {
		getName: function{
			return this.name;
		},

		getAge: function(){
			return this.age;
		}
	}
	※プロトタイププロパティに、オブジェクト形式で入っている

	<プロトタイプチェーン>
	参照されたプロパティがオブジェクトにない場合、プロトタイプのオブジェクトをたどり、該当するプロパティがあればそのプロパティが参照される仕組みのこと。直上のオブジェクトのプロトタイプだけでなく、その上にまだプロトタイプがあればnullになるまでさかのぼる。
	※逆の参照は行われない。

	-プロトタイプの継承方法
	子オブジェクトのprototypeに親オブジェクトのインスタンスを代入する
-------------------------------------------------------
	function User(){};
	User.prototype.a = "relax";

	function Member(){};
	Member.prototype = new User(); // 継承
	Member.prototype.b = "nervious";　//継承より先にMember固有のprototypeを記述すると継承によって上書きされる

	var user = new User();
	var member = new Member();

	console.log(user.a);　//relax
	console.log(member.a); //relax //プロトタイプチェーンによる参照
	console.log(member.b); //nervious
	console.log(user.b); //undefined　//親オブジェクトから子オブジェクトのprototypeの参照は不可
---------------------------------------------------------


<Stringオブジェクト>
インスタンスプロパティは、lengthのみ
インスタンスメソッドは、
concat()　:　文字列を結合し、結果文字列を返す。
substr()　:　第一引数に指定したインデックスから、第二引数分の長さの文字列を返す
substring()　:　開始インデックスと終了インデックスを指定して、そこのある文字列を返す。
※他のオブジェクトとほぼ一緒
indexOf(), lastIndexOf(), slice(), split(), match(), replace(), search()


<Array>
コンストラクタプロパティは　length
コンストラクタメソッドは　isArray() : オブジェクトが配列かどうか判別する

インスタンスメソッド
ｰ破壊的メソッド
	ｰスタックメソッド
	配列の末尾を扱うメソッド
		<push()>
		配列の末尾に要素を追加し、追加後の配列の長さを返す

		<pop()>
		配列の末尾の要素を削除し、削除された要素を返す

	ｰキューメソッド
	配列の先頭を扱うメソッド
		<unshift()>
		配列の先頭に要素を追加し、追加後の配列の長さを返す。

		<shift()>
		配列の先頭の要素を削除し、削除された要素を返す。

ｰその他メソッド
<concat()>
引数に指定した配列を結合し、新しい配列を返す
元の二つの配列に影響は与えない

<indexOf()>
引数に指定した値とマッチする要素を探し、最初にマッチした要素のインデックスを返す。
マッチしない場合はｰ1を返す
　ー<lastIndexOf()>
	ほぼindexOf()と同じだが、複数の要素にマッチした場合は最後にマッチした要素のインデックスを返す。

<splice()>
配列の任意の場所に要素を削除、追加できる。
splice()で削除した場合、削除した要素の配列が返される。
引数：インデックス、削除する数(0の場合削除しない)、追加したい要素...

<sort()>
整列

<reverse()>
逆順

<map()>
配列の全ての要素に対し、引数に指定した関数の処理を施し、その結果の配列を返す。元の配列に影響はない


ｰArray.forEach(function(val){
	console.log(val);
});
配列に対してEach処理を行う
引数のFuncに変数valを設定し、valに各要素を代入する。nullはスキップされる。

引数は3つ受け取れる
1つ目：要素
2つ目：インデックス
3つ目：配列（自身）

これらを処理の中で使える。


<toString()>
配列とその要素を表わす文字列を返す
--------------------------------------
const array1 = [1, 2, 'a', '1a'];

console.log(array1.toString());　// "1,2,a,1a"
---------------------------------------



<配列のコピー>
配列は他の変数に代入しても、参照渡しのためコピーできない
=>slice()を使ってコピーできる


<Date>
引数なし　=>　現在時刻
"11/1/2012" => Thu Nov 01 2012 00:00:00
(2018, 2, 22, 12,16, 00) => Thu Mar 22 2018 12:16:00 // 月は0月から始まる

コンストラクタメソッド
Date.now() => UTCからの経過時間をミリ秒単位で返す
Date.UTC() => UTCから引数までの経過時間をミリ秒単位で返す。

インスタンスメソッド
	-get系
	getDate() => 日付(1～31)
	getDay() => 曜日(1～6)
	getFullYear() => 西暦(4桁)
	getHours() => 時(0～23)
	getMilliseconds() => ミリ秒(0～999)
	getMinutes() => 分(0～59)
	getMonth() => 月(0～11)
	getSeconds() => 秒(0～59)
	getTime() => UTCからの経過時間をミリ秒単位

	-set系
	setDate(日) => 日を設定する
	setFullYear() => 西暦を設定
	setHours() => 時間を設定する
	setMilliseconds() => ミリ秒
	setMinutes() => 分
	setMonth() => 月
	setSeconds() => 秒
	setTime() => UTC経過時間

	-to系
	toDateString() => Dateオブジェクトの日付を英語表記で返す
	toTimeString() => Dateオブジェクトの時刻を文字列で返す。
	toUTCString() => UTCの文字列で返す
	valueOF() => UTCからの経過時間をミリ秒単位の時刻で返す
	その他
	-toISOString()
	-toJSON()
	-toLocaleDateString()

<Mathオブジェクト>
インスタンスが不要

-コンストラクタプロパティ
	・PI　円周率
	・SQRT2　2の平方根

-コンストラクタメソッド
	・abs()　引数の絶対値
	・ceil()　引数の小数点以下切り上げ
	・floor()　引数の小数点以下切り下げ
	・log()　引数の自然対数
	・max()　引数内の最大値を返す
	・min()　引数内の最小値を返す
	・pow(x,y)　xをyで累乗した値
	・random()　0以上1未満の乱数
	・round()　引数を四捨五入
	・sqrt()　引数の平方根


<ランダム値>
Mathオブジェクトのrandom()を使う。ランダム値に必要数＋1をかけて使う。

<組み込み関数>
isNaN(値) 引数の値がNaNか判定
parceFloat()　文字列　=>　浮動小数点
parceInt()　文字列　=>　整数

<NaN>
Not a Numberのことで、Numberオブジェクトに属すが、数値以外を表わすもの。
0の除算や、NaNを用いた演算を行うと結果として出力される

<URL>
ページの番地と情報を渡すクエリパラメータで構成される。
https://rfs.jp/?パラメータ名=パラメータの値&パラメータ名=パラメータの値・・・
※&(アンパサンド)で区切ることで、複数のパラメータを指定できる

-エンコード
	https://rfs.jp/?s=関数　=>  https://rfs.jp/?s=%E9%96%A2%E6%95%B0

encodeURI()　:URL全体をエンコードするには便利。メタ文字や記号はエンコードしない。

encodeURIComponent()　:文字列としての記号をエンコードする場合にはこっちを使う。全てエンコードする。
例)パラメータ値に&が使われる時、url = "https://rfs.jp/?s=" + encodeURIComponent("A&B");

-デコード
	decodeURI()　:encodeURI()に対応
	decodeURIComponent()　:encodeURIComponent()に対応
※デコード出来ない文字列がある場合、エラーでスクリプト終了する。
なので、これらのメソッドを使う場合は例外処理のtry catch文で処理する。


<エスケープ>と<エンコード>

-エスケープ
HTMLでは「< 」を「＆ｇｔ；」へ変換することをエスケープ処理と呼称します。
この場合、画面上はエスケープしても「<」と表示されるので内部処理上は見た目が変わりますが、
画面表示する際はエスケープ後文字列そのものは表示されません。

-エンコード
情報を暗号や通信に適した形式（コード）に変換すること。動画などの場合、この「形式」のことをコーデックと呼びます。
例えばURLコードへエンコードすると「半角スペース」は「%20」へ置換されます。そしてURLを見てみるとエンコード後の文字列がそのまま表示されています。


<ブラウザオブジェクト>
ドキュメントを含む、様々なブラウザの機能にアクセスするためのオブジェクト郡

階層構造を成しており、最上位のwindowオブジェクトから下層のオブジェクトにアクセスできる
【ドット記法】
window.location.href（通常はwindow省略）

<windowオブジェクト>
ダイアログボックス、スクロールなどのウィンドウ操作、印刷などを行うメソッド、画面サイズ、スクロール位置を取得するプロパティを持つ

プロパティ（インスタンスプロパティ？　どちらかというと）
	-frameElement　:　自身を開いている元のフレーム要素を返す(ウィンドウが別の文書に埋め込まれている場合)
	-frames　:　すべてのフレームにアクセスするための配列を返す
	-innerHeight　:　スクロールバーを含むブラウザウィンドウの内側の高さを返す
	-innerWidth　:　スクロールバーを含むブラウザウィンドウの内側の横幅を返す //コンテンツとスクロールバーの範囲（タブとかは含まない)
	-outerHeight　:　ブラウザウィンドウ全体の高さを返す
	-outerWidth　:　ブラウザウィンドウ全体の横幅を返す　//タブとかメニューを含め、ブラウザのウィンドウ全体
	-pageXOffset　:　ページの左端から水平方向にスクロールした位置をピクセルで返す
	-pageYOffset　:　ページの上端からスクロールした位置をピクセルで返す　//端からどれだけ離れたところにスクロールしているか
	-screenX　:　ウィンドウの水平方向の位置を返す
	-screenY　:　ウィンドウの垂直方向の位置を返す　//画面とウィンドウの位置関係

メソッド
	-alert()　:　OKボタンのみのアラートダイアログを表示する
	-confirm()　:　確認ダイアログを表示する。OK、キャンセルのどちらを押したかを返す
	-prompt()　:　入力ダイアログを開く。OKを押した場合は入力した値、キャンセルの場合はnullを返す
	-print()　:　印刷ダイアログを開く
	-scroll()　:　絶対位置を指定してスクロールする
	-scrollBy()　:　相対位置を指定してスクロールする
	-setTimeout()　:　指定した時間が経過した後、コールバック関数を実行、もしくは式の評価を行うtimeoutIDを返す
	-clearTimeout()　:　setTimeout()が返すtimeoutIDを使って、登録されたタイマー処理を削除する
	-setInterval():　指定した間隔でコールバック関数、もしくは式を繰り返し呼び出します。intervalIDを返す
	-clearInterval()　:　setIntervalが返すintervalIDを使って、登録されたタイマー処理を削除する

<タイマー処理>
setInterval()を使って、繰り返しコールバック関数を実行することで、連続的に動的変化を起こす
----------------------------------------------------------------------------------
window.setInterval( function() {     // ID名timerの要素の内容に、現在時刻を出力
	document.getElementById( "timer" ).innerHTML = new Date().toLocaleString();
}, 1000 );

-----------------------------------------------------------------------------------
第一引数:コールバック関数
第二引数:実行間隔（ミリ秒）
第三引数以降：自由

返値:intervalID
=>clearInterval()に渡して実行すると、処理を削除する

<setTimeout()>
setInterval()と同じような動作。ただし、処理は1回のみ。


<Formオブジェクト>

	HTML　フォーム要素
		-テキストボックス
			<input type="text"> //1行文のテキスト入力
		-ラジオボタン
			<input type="radio">　//どれか一つのボタン選択を受け付ける
		-チェックボックス
			<input type="checkbox">　//複数のボタン選択を受け付ける
		-パスワード入力ボックス
			<input type="password">　//パスワード入力を受け付ける
		-セレクトボックス
			<select>　//一つ、もしくは複数のメニュー選択を受け付ける
		-テキストエリア
			<textarea>　//複数行のテキスト入力を受け付ける
		-ボタン
			<button type="button">　//ボタンに関連づけられたアクションはなく、Javasriptで処理することが前提のボタン
		-リセットボタン
			<button type="reset">　//フォームに入力された内容などをリセットする
		-サブミットボタン
			<button type="submit">　//フォームをサーバに送信する

		-オプション
			<option>　//セレクトボックスの項目を設定する
		-ファイル選択
			<input type="file">　//ファイルを選択するモーダルダイアログを表示し、選択したファイルのパスを受け取る
		-非表示データ
			<input type="hidden"> //表示されないが、サーバには送信される

		-メールアドレス
			<input type="mail">
		-検索テキスト
			<input type="search">
		-電話番号
			<input type="tel">
		-URL
			<input type="url">

		-数値
			<input type="number">
		-レンジ
			<input type="range">
		-色
			<input type="color">

		-日付
			<input type="date">
		-UTCによる日時
			<input type="datetime">
		-ローカル日時
			<input type="datetime-local">
		-月
			<input type="month">
		-週
			<input type="week">
		-時間
			<input type="time">

			<参考>　https://codepen.io/tomatosoup1206/pen/PoPOQbR


	フォームへのアクセス
		-getElementById()、getElementByClassName()でもアクセス可能

			しかし、フォーム要素にID名かクラス名が必要

		-Formオブジェクトを使ってアクセス

			-連想配列でアクセス
				document.forms[インデックス/name属性].elements[インデックス/name属性]
				document.forms[インデックス/name属性][インデックス/name属性]

			※document.formsは、フォームの配列を返すので、フォームのインデックスを指定するか、name属性をしていする。
			※インデックスはコード内の順番通りに割り振られる。（HTMLの順番をいじると、変更が難しいため通常は使わない）
			※あるフォームの全ての要素に対して処理する場合は、インデックスを使ってfor文を回すのが便利

			-ドット記法でアクセス
				document.フォームのname属性.フォーム要素のname属性


	フォーム要素の操作
		プロパティはJavascript内で、取り出したformオブジェクトにドット記法で付けるだけ
			有効にしたい場合は、アクセス後に　= true　とする。

		-値をいじる
			valueプロパティ

		-フォームの入力不可
			disabledプロパティ

		-ラジオボタン/セレクトボックスの選択
			checkedプロパティ/selectedプロパティ

		-選択肢の個数（セレクトボックス、ラジオボタン、チェックボックスなど）
			lengthプロパティ

		-選択肢の初期値
			defaultCheckedプロパティ

		-選ばれている選択肢のインデックスの取得
			selectedIndexプロパティ

		-テキスト内容
			textプロパティ

		-テキストの選択
			select()メソッド

		-テキストエリアの行数変更
			rows()プロパティ

		-イベントのデフォルト動作を停止
			preventDefault()
			=>イベントが行われた時、defaultで決まっている動作があるが、その動作を停止させるメソッド。
			-------------------------------------------------------------------------------------------
				document.forms[].addEventListener("submit", function(a){
					a.preventDefault();       //勝手にaをsubmitだと判定してる？　もしくは、preventDefault()が設定の時、その処理を行わないって内容なのかもしれない
				});
			-----------------------------------------------------------------------------------------
				//つまり、submitされた時、preventDefault()（初期動作をしない）ことを実行するから、submitを判定。aは特に関係ない？


<Locationオブジェクト>
URL情報の取得、ページ移動、リロードなどを行う。

	-プロパティ
		-hash　:　ドキュメントの#以降のアンカーを取得、もしくは指定したアンカーに移動
		-host　:　ドキュメントのポート番号を含めたホスト情報を取得、設定
		-hostname　:　ドキュメントのホスト名を取得、設定
		-href　:　ドキュメントのURLを取得、もしくは指定したパスへ移動
		-pathname　:　ドキュメントのパスを取得、もしくは指定したパスへ移動
		-port　:　ドキュメントのポート番号の取得、設定
		-protcol　:　ドキュメントのプロトコルの取得、設定
		-search　:　ドキュメントのクエリを取得、設定

	-メソッド
		-assign()　:　指定したURLへ移動。新しいURLは閲覧履歴に追加され、ヒストリーバックで元のページに戻れる。
		-reload()　:　現在のページを再度読み込み
		-replace()　:　指定したURLへ移動。新しいURLと置換するので、ヒストリーバックで元のページに戻れない。


<アンカー>
ページ内で、さらに細かく遷移先を指定したもの
※URLの#以降の部分

<クエリ>
-データベースに出す命令(検索)のこと
-検索エンジンに出す検索ワードのこと
※URLの?以降の部分　パラメーターのところ


<Historyオブジェクト>
	履歴にアクセスできるオブジェクト
	-メソッド
		histroy.back()　:　一つ前のページに戻る
		history.forward()　:　一つ先のページに進む


<Navigaterオブジェクト>
	ユーザーエージェントからブラウザの種類やバージョン情報などを取得できる。

	-navigater.appCodeName　:　ブラウザのコード名(プログラムの名前的な)
	-navigater.appName　:　ブラウザの名前
	-navigater.appVersion　:　ブラウザのバージョン
	-navigater.userAgent　:　ブラウザのユーザーエージェント

	※これを用いて、メディアクエリなんかもできる


<screenオブジェクト>
	ディスプレイのサイズや、色数などの情報を取得できる。

		-screen.width　:　ディスプレイ幅
		-screen.height　:　ディスプレイ高さ
		-screen.availWidth　:　タスクバーなどを除くディスプレイ幅
		-screen.availHeight　:　タスクバーなどを除くディスプレイ高さ




<DOM>(ドキュメントオブジェクトモデル)
HTMLをオブジェクトとして扱うための規格で、HTMLをツリー上の集合として管理する。

	<getElementById()>
	HTML要素を取得（ID値指定）返り値は取得要素のオブジェクト
	同じIDが複数ある場合は、最初にヒットしたもの
	ない場合はnullを返す


	<innerHTML>
	HTML要素のコンテンツのプロパティ
	innerHTML()はHTMLを解析して、表示する
	例) p1.innerHTML = "<b>Hello</b>" // Hello
	　  p2.textContent = "<b>Hello</b>" // <b>Hello</b>
	※先にあった要素や文字列を上書きするため、追加したい場合は加算代入演算子などを使って追加する。


	<textContent>
	HTML要素のテキストのプロパティ

	<innerText>
	textContentと似て非なるもの。違いはあるが、使いわけは不明


	<getElementByClassName()>
	指定したクラスのHTML要素を取得し、その要素の配列を返す

	<getElementByTagName()>
	ほぼgetElementByClassName()と一緒。タグ名で要素を取得する

	<querySelector()>
	CSSセレクタを使って要素を取得する。（最初の一つだけ）
	document.querySelector(セレクタ名)

	CSSセレクタなので、指定する際、
	要素名　=>　("div")
	ID名　=>　("#list")
	クラス名　=>　(".list")　と表記する。

	※:last-childなども使える

	※query系のメソッドは、取得後にHTML側で要素が変更されても、動的に内容が更新されない。
	　処理速度も要素を取得するメソッドの中では遅い
	=>　処理速度が重要、取得後も最新の要素である必要である場合は、get系のメソッドを使う。

	<querySelectorAll()>
	querySelector()の複数ヒットするバージョン
	配列を返す
	※要素を追加する場合は、　配列[新しいインデックス].innerHTML += ""


	<appendChild()>
	指定した要素の最後に要素を追加できる（上書きはしない）
	※下に用例

	<createElement()>
	ノードを生成するメソッド
	※下に用例
	---------------------------------------------------
		// .list要素を取得
		var list = document.querySelector( ".list" );

		// 挿入用ノードの作成
		var li = document.createElement( "li" );

		// LI要素のテキストを設定
		li.textContent = "4" ;

		// 作成した要素を.list要素に追加
		list.appendChild( li );
	---------------------------------------------------


	<classListオブジェクト>
	取得した要素のクラス名の追加や変更ができる
	-add()　=>　要素に指定したクラスの追加
	-contain()　=>　要素に指定したクラスを含むかの論理値を返す
	-remove()　=>　要素から指定したクラスを削除する
	-toggle()　=>　要素に指定したクラスがあれば削除、なければ追加する
	-------------------------------------------------------------------
	// LIの最後の要素を取得
	var li = document.querySelector( ".list li:last-child" );
	// クラス名を追加
	li.classList.add( "current" );
	--------------------------------------------------------------


	<styleオブジェクト>
	取得した要素はstyleオブジェクトを介して、CSSを変更できる（Javascriptでの変更が最優先される）
	=styleプロパティを使う
	btn.style.backgroudColor = "red";

	backgroud-color => backgroundColor


	<link要素を使ったスタイルの変更>
	Linkタグで、外部のスタイルシートを読み込んでいるので、そのLinkをdisabled属性を使って変更する方法
	-----------------------------------------------------------------------
	// ボタン要素を取得し、クリックのイベントリスナーを登録
	document.getElementById( "btn-change" ).addEventListener( "click", function(){
	// disableのトグル処理
	document.getElementById( "style-change" ).disabled = !document.getElementById( "style-change" ).disabled;
	} );
	-----------------------------------------------------------------------------------
	※こんなトグル処理もある。


<メソッドチェーン>
ドット記法を使ってメソッド後にメソッドを複数つなげること
できるものとできないものがある

<ユーザーエージェント>
ユーザーエージェントとは、あるホームページにアクセスしたときに伝える、自分自身の情報のことです。利用しているOS（WindowsかMac OS）やブラウザ、スマートフォンの機種などの情報を伝えます。

<viewport>
コンテンツを表示する領域（ウィンドウ）


<クロスブラウザ問題>
ブラウザ毎に仕様が異なる問題

<apply()>
ある関数に引数を渡すに当たって、その関数の引数の形に合わせて引数を渡すのは面倒なので、Apply()メソッド使って渡す。
例)var list = [1,2,3]
max(1,2,3) => max.apply(null, list)
これで済む

第1引数はapplyメソッド内でのthisの参照先を指定する

call()メソッドとの違いは、第2引数以降の渡し方が配列かどうかだけ。




<関数の返値>
return指定なしの場合undefined

<関数定義前の行での使用も可能>

<無名関数>
１．関数を変数代入時
var func = function(){:::};
２．即時実行関数(一回しか使わないときの処理)
( function(){:::})();
目的は様々だけど、スコープの制限にも使われる
(変数スコープは関数なので)

<クロージャ>
---------------------------------
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2)); // 7 と表示される
console.log(add10(2)); // 12 と表示される
-------------------------------------------
まずある関数に内包された関数はその親関数のプロパティを参照できる（これはグローバル関数の参照ができるのとおなじ感じ)
例)makeAdder()の引数xを、無名関数は参照できる

次に、add5に格納された値は、makeAdder()の返値であるfunction(y)である。そして、console.log()でfunction(y)に引数を与えて出力している。

javascriptの特徴として、内包された関数はその作成された環境を一緒に記録している。（=クロージャしている）

そのため、一見add5には返値のfunction(y)しか入っておらず、xは参照できないように見えても、その関数の作成された環境であるmakeAdder()をfunction()は記録しているので、function(y)はxを参照できる。

要は、関数が一つのクラスみたいになっている感じかな(感想)

<再帰関数>
自分自身を呼び出す関数のこと
-------------------------------
function loop(x){
if(x>20) return; //再起関数終了条件
console.log(x);
    loop(x + 1); //再起呼び出し
}
loop(1); //1~20出力
----------------------------------

<短絡演算子>
&& と || と !!

&&は論理演算子であって、演算としては左側のオペランドがfalseの場合右オペランドは確認しない（必要がないから）
つまり、以下のように使える
-------------------------------------
/\W/.test(password) && alert('無効な文字が含まれています')
// `\W`がパスワードに含まれていた場合のみ`alert`する
// 含まれていない場合は無視される
----------------------------------
const foo = hoge || huga;
// `hoge`がある場合はそれを代入する。`huga`は無視される
// ない場合は`huga`を`foo`に代入する
-----------------------------------
!!hoge
// 一度`!`で、真偽値にしたあと、また`!`で逆転してしまったのを戻している。（値をboolean型に変換している）
// ↓と同じ
hoge = hoge ? true : false;

<return>
返値の指定の他にメソッドの終了を命令できる
if return; // undefinedを返す


<正規表現>
特定の文字を見つけ出すための機構
リテラルは/で囲む。
メタ文字の特殊な意味を使う。

var pet = /a.*e/
=>始めがaで途中何があるか分からないが最後がeの文字列

-メタ文字
	・量指定子(最大数にマッチするから注意)
	. => 改行以外の1文字にマッチ
	* => 直前文字が0回以上繰り返しにマッチ
	+ => 直前文字が1回以上繰り返しにマッチ
	? => 直前の文字の0回か1回にマッチする(なんなら単語の途中で切ってマッチすることもある
	例)　/se?/ => she - s, see - se, sea - se
	{m,n} =>直前の文字のm回以上n回以下の繰り返しにマッチ
	{m} => m回の繰り返し
	{m,} => m回以上の繰り返し

	・オプション
	g => 複数マッチ。マッチした全ての文字を配列で返す。
	i => 英字の大文字、小文字を判断しない
	m => 複数行に対応したマッチ。複数行で行頭(^)と行末($)が有効になる

	・アンカー(文字列中の位置にマッチ)
	^ (キャレット) => 行頭にマッチ。複数行検索の場合は、各行頭もマッチ。[]内では補集合を表わすので注意
	$ (ダラー) => 行末にマッチ。複数行検索の場合は、各行末もマッチ。
	\b => 単語の区切りにマッチ。単語の区切りは\Wと一緒。
		　しかし、\bの場合は区切りは出力されない
	\B => 単語区切り以外の文字にマッチ。
		　例)　man => /\Ba/ => a
	X(?=Y) => Xの後ろにYが続く場合のみマッチ。
	X(?!Y) => Xの後ろにY が続かない場合のみマッチ。

	・文字クラス
	[] => ブラケットで囲んだ1文字以上の集合を文字クラスという。
	そして、文字クラスをパターンに使うと、文字クラス内のどれか1文字に当てはまる文字があればマッチする。
	文字クラスの中ではメタ文字も普通のリテラルとして扱われる
	ｰ文字クラス内でハイフンを使うと範囲指定
	例)[a-z], [0-9],[a-zA-Z]
	[^] => ブラケットに含まれない任意の１文字にマッチする(補集合)
	\w => アンダースコアを含む英数字1字にマッチ
	\W => アンダースコアを含む英数字以外の1字にマッチ
	\d => 数字の1字にマッチ
	\D => 数字以外の1字にマッチ
	\s => 空白文字にマッチ
	\S => 空白文字以外にマッチ

※文字集合の中でメタ文字をリテラルとして使いたい場合、\を付けてエスケープする。

-match()メソッド
文字列.match(パターン)
返値：配列のインデックス0に入っている

例)
//　match()メソッド
var pat = /a.*e/;
var str = "abcdefg";
var ret = str.match(pat);
console.log(ret[0]); // abcde

//g　メタ文字
"ABCDE".match(/./g);
=> ["A","B","C","D","E"]


-(X)で囲う
括弧で囲んだパターンがマッチした場合、その文字列をRegExpオブジェクトに記録する
記録を呼び出す方法：RegExp.$1, RegExp.$2のように、括弧で囲んだグループを左から順番に呼び出せる
後方参照も可能
例)
--------------------------------
"After all, tomorrow is another day.".match(/^(\w+)/);
RegExp.$1// "After"
--------------------------------
var str = "after all, tomorrow is another day.";
str.replace(/^(\w)/, RegExp.$1.toUpperCase());
=> After all, tomorrow is another day.
※replace内であればRegExpを省力できる
------------------------------------

-(?:X)で囲う
グループ化して、RegExpに記録するが、後方参照を行わない
(グループ化の際、後方参照を可能にするように記録すると少し処理が必要のため)

-パイプを使う
| パイプの前後にある正規表現のどちらかにマッチする
X|Yであれば、XかYのいずれかにマッチする。
gオプションを使うとどちらの選択もマッチするようにできる。

<RegExpオブジェクト>
正規表現を表わすオブジェクト

<後方参照>
検索パターンの中で前でキャプチャーした文字列を参照すること

<replace()>
第一引数のパターンにマッチした文字列の一部または全部を第二引数の文字列もしくは関数で置き換えた文字列を返す。
------------------------------------------------
var str = "after all, tomorrow is another day!";
str.replace(/^(\w)/, function($1){return $1.toUpperCase();});
//"After all, tomorrow is another day!"
-------------------------------------------

<search()メソッド>
引数に渡したパターンにマッチした場所のインデックスを返す。

<split()>
指定した区切りパターンで、文字列を分割して配列を返す。
第一引数に区切り文字を指定
第二引数に分割数の指定
例)
"One,Two,Three".split(",");
=> ["One","Two","Three"]

"One Two Three".split(/\s/, 2);
=> ["One","Two"]

※joinの逆メソッド

<test()>
文字列がマッチするかの真偽値を返す
（文字列が必要な場合はmatch()）



<forの入れ子の処理数を減らす>

-各配列の要素の種類とその個数をカウントするオブジェクトを作り、それを比較する
　各要素をそれぞれ一個ずつ比較せず、カウンタ同士を比較するから、処理が累乗にならない
-------------------------------------------------
function same(arr1, arr2) {
 if (arr1.length !== arr2.length) {
   return false;
 }　//長さチェック

 let frequencyCounter1 = {};
 let frequencyCounter2 = {};

　//カウンター生成
 for (let val of arr1) {
   frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
 }

 for (let val of arr2) {
   frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
 }
-----------------------------------------
 //オブジェクト[]で、プロパティを作成
 （各要素が何個ずつあるかのカウンターオブジェクト生成）

{ '1': 1, '2': 2, '3': 1 } //元の配列[1, 2, 3, 2]
{ '1': 1, '4': 2, '9': 1 } //元の配列[9, 1, 4, 4]

-----------------------------------------
 //オブジェクト同士を評価
 for (let key in frequencyCounter1) {
   if (!(key ** 2 in frequencyCounter2)) { //まず値が存在するか
     return false;
   }
   if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {　//その頻度が同じか
     return false;
   }
 }

//console.log(frequencyCounter1);
//console.log(frequencyCounter2);
 return true;
}

//console.log(same2([1, 2, 3, 2], [9, 1, 4, 4]));

---------------------------------------------------------


<CSS>

	<display: flex>
	ある要素に定義するだけで、その直下の要素が並列になる便利なスタイルです。
	シンプルな導入であれば、CSSで「display:flex」というスタイルを指定するだけです。

	<justify-contentプロパティ>(CSS)
	コンテナ内全体の主軸方向（初期値では横方向）の揃え位置を指定する
	※子要素とスペースの配置の関係
	-flex-start
	行頭寄せ、通常は左揃え（初期値）
	-flex-end
	行末寄せ、通常は右揃え
	-center
	センター揃え
	-space-between
	アイテムの間にスペースを均等に割り付け
	-space-around
	アイテムの両端にスペースを均等に割り付け

	<align-items>
	子要素の高さ方向の寄せを指定するプロパティ
	align-items: stretch;//子要素のcontentがめいっぱい広がる
	align-items: center;//子要素の高さの真ん中にcontentが配置
	align-items: start;//上段寄せ
	align-items: end;//下段寄せ

	<flex-basis>
	フレックスアイテムの主要部分の初期の寸法を設定します。
	box-sizingで設定していない限り、このプロパティはコンテンツボックスの寸法を定義します。
	flex指定の親ボックスの子要素の主要部分のサイズを指定するプロパティ

	<overflow>
	overflowプロパティは、ボックスの範囲内に内容が収まらない場合に、はみ出た部分の表示の仕方を指定する
	-値
	visible　:　内容がボックスに収まらない場合、ボックスからはみ出して表示される（初期値）
	hidden　:　内容がボックスに収まらない場合、収まらない部分は非表示となる。内容が収まらない場合にも、スクロールバーなどは表示されない
	scroll　:　内容がボックスに収まらない場合、収まらない部分はボックスからはみ出さない。内容が収まらない場合には、スクロールバーなどが表示される
	auto　:　ボックスに収まらない内容をどう表示するかは、ユーザーエージェントに依存する。内容が収まらない場合には、スクロールバーなどが表示される
	no-display　:　内容がボックスに収まらない場合、display：none; が指定されたかのようにボックス全体が削除される
	no-content　:　内容がボックスに収まらない場合、visibility：hidden; が指定されたかのようにボックス全体が非表示となる


	<position>
	positionプロパティは、ボックスの配置方法（基準位置）が、相対位置か絶対位置かを指定する際に使用します。
	-値
	static　:　特に配置方法を指定しません。この値のときには、top、bottom、left、rightは適用されません。これが初期値です。
	relative　:　相対位置への配置となります。positionプロパティでstaticを指定した場合に表示される位置が基準位置となります。(本来表示される位置を基準に変更)
	absolute　:　絶対位置への配置となります。親ボックスにpositionプロパティのstatic以外の値が指定されている場合には、親ボックスの左上が基準位置となります。
	fixed　:　絶対位置への配置となるのはabsoluteと同じですが、スクロールしても位置が固定されたままとなります。

	top、bottom、right、left
	=>その要素がstaticで無いときに、ブロックのpositionの設定関係を参考に、それぞれ上下右左からの距離を取って配置する

	<z-index>
	z-indexプロパティは、ボックスの重なりの順序を指定する際に使用します。 z-indexプロパティは、positionプロパティでstatic以外の値が指定されている要素に適用されます。
	-値
	整数値で指定　:　重なりの順序を整数で指定します。0を基準として、値が大きいものほど上になります。
	auto　:　親要素と同じ階層になります。これが初期値です。

	<transition>
	遷移 (transition) によって、要素の2つの状態間の変化を定義することができます。
	それぞれの状態は :hover や :active のような疑似クラスで定義するか、 JavaScript を使用して動的に設定します。

	<&セレクタ>
	ブロックの親セレクタを参照し、その名称を書いたのと同じ効果

	<@import url()>
	フォントファイルなどの読み込みに使う
	　-bodyをターゲットにfont-familyで読み込んで使う

	<Saasの変数>
	Saasが提供する変数。
	$bg-color: #fff
	のように、先頭が$、変数名と値を:で区切る
	色、サイズ、パスなどなんでも格納できる
	※変数が使えるようになるため、効率とデバックがしやすい
	文字列と区別しないとエラーとなる　=>　文字列内では、#{}で囲んで使う

	<疑似セレクタ>
	おそらくthisのように、セレクタ名とは別にターゲットを指定するセレクタ

	<:last-child>
	疑似セレクタの一つ。そのターゲットの最後の子要素をセレクトする。



<Saas>
Sassは「Syntactically Awesome StyleSheet」の略です。
SassはCSSのメタ言語というもので、簡単に言うと「CSSをさらに拡張して、より効率的に書けるようにしたよ」ということです。

<Webフォント>
Webサーバからフォントデータを読み込み、ページ内でそのフォントを利用できるようにします。
※Google Fontsなどがある
※英語のみのフォントは複数使っても、処理にさほど影響しないが、日本語はその多さ故に、複数使うと処理に影響を与える可能性がある